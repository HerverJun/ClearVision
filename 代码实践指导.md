# .NET 8 + WebView2 桌面应用开发计划：代码结构最佳实践

## 1. 技术栈与架构选型

### 1.1 核心技术组合

#### 1.1.1 前端呈现层：Microsoft Edge WebView2

**Microsoft Edge WebView2** 是基于 Chromium 内核的现代嵌入式浏览器控件，为 Windows 桌面应用提供了将 Web 技术深度集成到原生应用中的能力。WebView2 采用多进程架构设计，由单一主进程与多个渲染器进程组成，使用相同用户数据文件夹的各 WebView2 应用程序之间会共享非渲染器进程，从而显著降低内存占用。这一架构既保证了稳定性（单个页面崩溃不会影响整个应用），也提供了强大的安全隔离机制。

WebView2 提供两种运行时分发模式：**Evergreen Runtime**（全局共享，自动更新）和 **Fixed Version Runtime**（独立打包，版本锁定）。对于大多数应用场景，推荐使用 Evergreen 模式，该模式通过 Windows Server Update Services (WSUS) 自动接收更新，确保运行时始终与 Microsoft Edge 保持版本同步。Windows 11 系统默认包含 WebView2 Runtime，显著降低了终端用户的部署门槛。

从技术实现角度，WebView2 的初始化采用异步模式，必须通过 EnsureCoreWebView2Async 方法完成核心环境的准备。开发者需要特别注意，WebView2 的 CoreWebView2 属性在初始化完成前为 null，因此所有核心操作都应在 CoreWebView2InitializationCompleted 事件触发后执行。WebView2 提供了丰富的 API 用于深度定制，包括网络请求拦截（WebResourceRequested）、新窗口行为控制（NewWindowRequested）、脚本注入（ExecuteScriptAsync）以及主机与 Web 内容的双向通信（PostWebMessageAsString/WebMessageReceived）。

在桌面应用场景中，WebView2 的本地资源加载策略是关键设计决策。开发者可以选择通过 file:// 协议直接加载本地 HTML 文件（开发阶段推荐，支持热重载），或者将前端资源嵌入为程序集资源后通过虚拟主机名映射访问（生产环境推荐，简化部署）。Microsoft 官方示例 WebView2WindowsFormsBrowser 展示了完整的浏览器功能实现，为复杂桌面应用的 Web 视图集成提供了参考实现。

#### 1.1.2 后端服务层：.NET 8 + C# 12

**.NET 8** 作为长期支持（LTS）版本，为桌面应用后端提供了卓越的性能、稳定性和现代化语言特性。相较于 .NET 6/7，.NET 8 在多个维度实现了显著改进：启动时间优化约 15-20%，内存占用降低 10-15%，JSON 序列化性能提升 20% 以上。这些性能改进对于需要快速启动的桌面应用尤为关键。

**C# 12** 作为 .NET 8 的配套语言版本，引入了多项简化代码结构的特性：

| 特性 | 应用场景 | 代码简化效果 |
| --- | --- | --- |
| **主构造函数（Primary Constructors）** | 依赖注入服务、DTO 定义 | 消除 60-80% 的样板字段声明 |
| **集合表达式（Collection Expressions）** | 数组、列表、Span 初始化 | 统一语法，支持展开操作符 .. |
| **内联数组（Inline Arrays）** | 高性能缓冲区、协议解析 | 栈上分配，零 GC 压力 |
| **required 成员 + init-only 属性** | 不可变领域模型、配置对象 | 编译期强制完整初始化 |
| **文件作用域类型（File-scoped Types）** | 实现细节封装、辅助类 | 避免命名空间污染 |

在架构层面，.NET 8 的 **Minimal APIs** 提供了轻量级的 HTTP 端点定义方式，非常适合作为 WebView2 宿主的本地服务端。配合 ASP.NET Core 的依赖注入容器、配置系统和日志抽象，可以构建出既精简又功能完备的后端服务。对于需要进程间通信的场景，.NET 8 的 gRPC 支持也得到了增强，包括消息压缩优化和流处理能力提升。

#### 1.1.3 开发辅助：AI IDE（Cursor/Antigravity类工具）

AI 辅助编程工具正在重塑软件开发的工作流程。以 **Cursor** 和类似 **Antigravity** 的 AI IDE 为代表，这类工具通过深度集成大语言模型，提供了代码生成、智能补全、架构建议、自动化重构等能力。对于 .NET 8 + WebView2 技术栈的项目，AI 工具的价值体现在：

* **领域建模阶段**：根据业务描述自动生成实体类、DTO、验证逻辑，自动应用 C# 12 的 record、required 等特性
* **API 设计阶段**：根据 OpenAPI 规范自动生成前后端通信的契约代码
* **测试阶段**：基于实现代码生成边界条件和异常场景的测试用例
* **架构维护**：识别代码异味、建议重构方案、保持架构约束一致性

然而，AI 辅助开发的有效性高度依赖于**上下文质量和提示工程**。开发者需要为 AI 建立清晰的架构约束和代码规范，包括项目结构模板、命名约定文档、代码分析规则集（.editorconfig 和 .globalconfig）以及架构决策记录（ADR）。通过将这些约束编码为 AI 的系统提示或项目特定的知识库，可以引导 AI 生成符合团队标准而非通用模式的代码。

### 1.2 架构模式决策

#### 1.2.1 前后端分离架构 vs 深度集成模式

WebView2 桌面应用可以采用两种截然不同的架构模式，各有其适用场景和权衡考量：

| 维度 | **前后端分离架构（HTTP API）** | **深度集成架构（WebMessage/宿主对象）** |
| --- | --- | --- |
| **通信延迟** | 1-5ms（本地回环，含序列化） | <0.1ms（直接内存交换） |
| **进程模型** | 多进程（渲染进程 + Kestrel 服务进程） | 单进程或双进程 |
| **部署复杂度** | 较高（端口管理、服务发现、CORS 配置） | 低（单一可执行文件） |
| **前端工具链** | 完整支持（Vite、Webpack、TypeScript 等） | 需定制适配，与标准 Web 开发有差异 |
| **调试体验** | 优秀（标准浏览器 DevTools + API 测试工具） | 受限（需专用调试工具或日志） |
| **技术栈独立性** | 完全独立，前端可迁移至纯 Web | 高度耦合，前端依赖后端契约 |
| **安全边界** | 清晰（HTTP 层认证授权） | 需手动设计，精细控制暴露范围 |
| **适用场景** | 复杂业务、大型团队、多平台共享 API | 工具类应用、高频实时交互、快速响应需求 |

**前后端分离架构**将前端作为独立的 SPA（单页应用），通过 HTTP API 与后端通信。后端是一个完整的 ASP.NET Core 服务，通常托管在本地 Kestrel 服务器上。这种模式的优点在于技术边界清晰，前端可以完全复用现代 Web 开发工具链，前后端团队可以独立开发和测试，前端代码理论上可以迁移到纯浏览器环境。

**深度集成架构**则最大化利用 WebView2 的原生互操作能力，主要通过 WebMessage 机制进行双向通信，或将 .NET 对象直接暴露给 JavaScript 调用（AddHostObjectToScript）。这种方式消除了序列化和网络传输开销，提供了最低的调用延迟，但需要处理 COM 可见性、线程安全等复杂问题，且前端与后端存在编译期强耦合。

对于本计划的桌面应用，**推荐采用混合架构**：核心业务流程和状态管理通过 WebMessage 实现低延迟交互，数据查询和复杂业务逻辑通过本地 HTTP API 暴露，保证接口的清晰和可测试性。这种分层策略能够在性能和灵活性之间取得平衡，同时为未来的架构演进保留空间。

#### 1.2.2 分层架构适用场景分析

无论选择何种通信模式，后端代码都应遵循清晰的分层架构原则。对于 .NET 8 项目，推荐采用**领域驱动设计（DDD）风格的分层架构**：

| 层级 | 职责 | 依赖方向 | 典型内容 |
| --- | --- | --- | --- |
| **表现层（Presentation/API Layer）** | 处理外部交互 | 向上依赖应用层 | Controllers、Minimal API Endpoints、ViewModels、WebMessage 处理器 |
| **应用层（Application Layer）** | 编排用例流程 | 向上依赖领域层 | Services、DTOs、Validators、Mappers、用例处理器（CQRS） |
| **领域层（Domain Layer）** | 核心业务逻辑 | 无外部依赖 | Entities、Value Objects、Domain Services、Domain Events、聚合根 |
| **基础设施层（Infrastructure Layer）** | 技术实现细节 | 向上依赖领域层 | Repositories、DbContext、External Service Clients、消息队列适配器 |

这种分层结构的核心价值在于**依赖方向的严格控制**：领域层作为核心，不依赖任何其他层，确保业务逻辑的纯粹性和可测试性；基础设施层通过实现领域层定义的接口（如 IRepository<T>）完成具体的技术适配，遵循依赖倒置原则（DIP）。当需要更换数据库、缓存方案或外部服务时，只需替换基础设施层的实现，领域层和应用层保持完全不变。

对于中小型桌面应用，可以适当简化层次，将应用层和表现层合并为"宿主层"，但**领域层和基础设施层的分离应始终保留**。这种简化可以降低项目结构的复杂度，同时保持核心业务逻辑的可维护性。

#### 1.2.3 通信机制选择：HTTP API / WebMessage / 混合模式

基于前述分析，本项目的通信机制设计如下：

| 场景 | 推荐机制 | 理由 |
| --- | --- | --- |
| **CRUD 数据操作、复杂查询** | HTTP API | 标准语义、缓存友好、工具支持（Swagger/OpenAPI）、易于测试 |
| **实时通知、进度反馈、状态同步** | WebMessage | 低延迟、服务器主动推送、无需轮询 |
| **高频交互、即时响应 UI 操作** | WebMessage | 亚毫秒级延迟，避免 HTTP 开销 |
| **大文件传输、流式数据处理** | HTTP API + 共享内存缓冲区 | 利用 WebView2 的 PostSharedBufferToScript API 优化 |
| **原生功能调用（文件系统、系统 API）** | WebMessage + 宿主对象 | 精细控制权限边界，直接访问 .NET API |

**混合模式的设计原则**是将通信语义与机制匹配：命令（状态变更操作）通过 WebMessage 实现即时响应，查询（数据获取）通过 HTTP API 利用缓存和分页优化，实时通知通过 WebMessage 推送，大容量二进制数据优先考虑共享内存机制。这种分离在架构上对应 CQRS（命令查询职责分离）模式的局部应用，也为未来引入 SignalR 等真正的实时通信预留了扩展点。

## 2. 后端代码结构（.NET 8 + C# 12）

### 2.1 分层架构设计

#### 2.1.1 表现层（API Layer）：Controllers、Minimal APIs

在 .NET 8 中，表现层有两种主要实现方式：传统的 **Controller-based API** 和 **Minimal APIs**。对于 WebView2 桌面应用的后端服务，**Minimal APIs 是更推荐的选择**，原因如下：

首先，桌面应用的后端 API 通常规模有限，Minimal APIs 的简洁语法能够减少样板代码。其次，Minimal APIs 与依赖注入的深度集成，使得在单文件中定义端点、服务和配置成为可能，这对于 AI 辅助生成的代码更为友好。最后，Minimal APIs 的性能略优于 Controller 模式，虽然这在本地通信场景中差异微小，但体现了技术选型的前瞻性。

Minimal APIs 的基本结构示例：

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddApplicationServices(); // 扩展方法注册应用层
var app = builder.Build();

// 健康检查端点（WebView2 初始化验证）
app.MapGet("/api/health", () => Results.Ok(new {
    Status = "Healthy",
    Timestamp = DateTime.UtcNow
}));

// 带依赖注入的 CRUD 端点
app.MapGet("/api/documents/{id:guid}", async (
    Guid id,
    IDocumentService service,
    CancellationToken ct) =>
{
    var document = await service.GetByIdAsync(id, ct);
    return document is null ? Results.NotFound() : Results.Ok(document);
});

// 命令端点：创建文档
app.MapPost("/api/documents", async (
    CreateDocumentCommand command,
    IDocumentService service,
    CancellationToken ct) =>
{
    var result = await service.CreateAsync(command, ct);
    return result.IsSuccess
        ? Results.Created($"/api/documents/{result.Value.Id}", result.Value)
        : Results.BadRequest(result.Errors);
});

app.Run("http://localhost:0"); // 动态端口，实际应从配置读取
```

对于需要更复杂逻辑的场景，可以将端点处理器提取为静态方法或扩展方法，保持 Program.cs 的整洁。表现层的关键职责是**协议转换**——将 WebView2 的通信协议（WebMessage 或 HTTP）转换为应用层可处理的强类型命令/查询。

对于 **WebMessage 模式**，表现层需要实现一个中央消息分发器：

```csharp
public abstract class WebMessageHandler<TPayload> where TPayload : class
{
    public string MessageType => typeof(TPayload).Name
        .Replace("Command", "")
        .Replace("Query", "");
    public abstract Task<object?> HandleAsync(TPayload payload, CancellationToken ct);
}

public class WebMessageDispatcher
{
    private readonly IServiceProvider _serviceProvider;
    private readonly Dictionary<string, Type> _handlerTypes = new();

    public void Register<TPayload, THandler>()
        where TPayload : class
        where THandler : WebMessageHandler<TPayload>
    {
        var typeName = typeof(TPayload).Name
            .Replace("Command", "")
            .Replace("Query", "");
        _handlerTypes[typeName] = typeof(THandler);
    }

    public async Task<object?> DispatchAsync(
        string type,
        JsonElement payload,
        CancellationToken ct)
    {
        if (!_handlerTypes.TryGetValue(type, out var handlerType))
            throw new NotSupportedException($"Unknown message type: {type}");

        var payloadObj = payload.Deserialize(
            handlerType.BaseType!.GetGenericArguments()[0],
            JsonOptions.Default) as TPayload;

        var handler = _serviceProvider.GetRequiredService(handlerType);
        var method = handlerType.GetMethod("HandleAsync")!;
        return await (Task<object?>)method.Invoke(
            handler,
            new object?[] { payloadObj!, ct })!;
    }
}
```

#### 2.1.2 应用层（Application Layer）：Services、Use Cases、DTOs

应用层是"系统做什么"的表达，应当以**用例（Use Case）**为组织单元，而非以技术组件（Service）为中心。每个用例对应一个用户可感知的业务操作，如"创建文档"、"导出报表"、"同步设置"等。这种组织方式的优势在于可追踪性、可测试性和可演进性。

**DTO（数据传输对象）** 是应用层与表现层之间的契约载体，其设计直接影响前后端集成的效率与安全性。DTO 的核心原则是**最小暴露**——仅包含前端展示所需的属性，排除领域实体的内部标识、导航属性以及敏感字段。C# 12 的 record 类型是 DTO 的理想选择：

```csharp
// 请求 DTO：创建文档
public sealed record CreateDocumentRequest(
    required string Title,
    required string Content,
    string? Category = null,
    IReadOnlyList<string>? Tags = null
) : ICommand<Guid>;

// 响应 DTO：文档摘要
public sealed record DocumentDto(
    Guid Id,
    string Title,
    string Category,
    DateTimeOffset CreatedAt,
    DateTimeOffset ModifiedAt
);
```

required 修饰符确保关键字段在对象构造时必须提供，编译器会进行检查。init-only 属性（通过 record 的语法糖）防止对象创建后的意外修改。对于复杂的嵌套结构，集合表达式进一步简化初始化语法。

应用服务的注册应当采用**扫描注册**模式，避免手动维护注册代码：

```csharp
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddApplicationServices(
        this IServiceCollection services)
    {
        var assembly = typeof(ServiceCollectionExtensions).Assembly;

        // 自动注册所有命令和查询处理器（MediatR）
        services.AddMediatR(cfg =>
            cfg.RegisterServicesFromAssembly(assembly));

        // 自动注册验证器（FluentValidation）
        services.AddValidatorsFromAssembly(assembly);

        // 注册领域服务
        services.AddScoped<IDocumentService, DocumentService>();

        return services;
    }
}
```

#### 2.1.3 领域层（Domain Layer）：Entities、Value Objects、Domain Services

领域层是业务知识的核心载体，其设计质量直接决定系统的长期可维护性。在 .NET 8 + C# 12 的技术背景下，领域层应当充分利用以下特性：

**不可变值对象（Immutable Value Objects）** 使用 readonly record struct 定义，确保线程安全和行为可预测：

```csharp
public readonly record struct Money(decimal Amount, Currency Currency)
{
    public static Money operator +(Money left, Money right)
    {
        if (left.Currency != right.Currency)
            throw new InvalidOperationException(
                "Cannot add money with different currencies");
        return new Money(left.Amount + right.Amount, left.Currency);
    }

    public Money ConvertTo(Currency targetCurrency, decimal exchangeRate) =>
        new(Amount * exchangeRate, targetCurrency);
}

public enum Currency { USD, EUR, CNY, JPY }
```

**富实体（Rich Entities）** 封装业务规则，避免贫血模型。C# 12 的 required 成员和主构造函数简化了依赖注入和强制初始化：

```csharp
public class Order : Entity, IAggregateRoot
{
    private readonly List<OrderLine> _lines = new();

    // C# 12 required 成员：强制构造函数初始化
    public required string Title { get; init; }
    public required string Content { get; private set; }
    public string? Category { get; private set; }
    public OrderStatus Status { get; private set; }
    public IReadOnlyCollection<OrderLine> Lines => _lines.AsReadOnly();
    public DateTimeOffset CreatedAt { get; private set; }
    public DateTimeOffset ModifiedAt { get; private set; }

    // 私有构造函数用于 ORM/序列化
    private Order() { }

    // 工厂方法封装创建规则
    public static Order Create(
        string title,
        string content,
        string? category = null)
    {
        if (string.IsNullOrWhiteSpace(title))
            throw new DomainException("Title cannot be empty");
        if (title.Length > 200)
            throw new DomainException("Title cannot exceed 200 characters");

        return new Order
        {
            Id = Guid.NewGuid(),
            Title = title.Trim(),
            Content = content,
            Category = category,
            Status = OrderStatus.Draft,
            CreatedAt = DateTimeOffset.UtcNow,
            ModifiedAt = DateTimeOffset.UtcNow
        };
    }

    // 领域行为方法
    public void UpdateContent(string newContent)
    {
        if (Status == OrderStatus.Archived)
            throw new DomainException("Cannot modify archived document");
        Content = newContent;
        ModifiedAt = DateTimeOffset.UtcNow;
        AddDomainEvent(new DocumentContentUpdatedEvent(Id));
    }

    public void AddTag(string tag)
    {
        var normalizedTag = tag.Trim().ToLowerInvariant();
        if (_tags.Contains(normalizedTag)) return;
        if (_tags.Count >= 10)
            throw new DomainException("Cannot add more than 10 tags");
        _tags.Add(normalizedTag);
        ModifiedAt = DateTimeOffset.UtcNow;
    }

    public void Publish()
    {
        if (Status != OrderStatus.Draft)
            throw new DomainException("Only draft documents can be published");
        Status = OrderStatus.Published;
        ModifiedAt = DateTimeOffset.UtcNow;
        AddDomainEvent(new DocumentPublishedEvent(Id));
    }
}
```

**领域事件（Domain Events）** 实现跨聚合的最终一致性：

```csharp
public interface IDomainEvent
{
    Guid EventId { get; }
    DateTimeOffset OccurredAt { get; }
    Guid AggregateId { get; }
}

public abstract class DomainEventBase : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTimeOffset OccurredAt { get; } = DateTimeOffset.UtcNow;
    public abstract Guid AggregateId { get; }
}

public sealed record DocumentPublishedEvent(Guid DocumentId) : DomainEventBase
{
    public override Guid AggregateId => DocumentId;
}
```

#### 2.1.4 基础设施层（Infrastructure Layer）：Repositories、External Services

基础设施层提供技术能力的实现，将领域层定义的抽象接口适配到具体的技术组件。

**仓储实现（Repository Implementations）** 封装数据访问逻辑。推荐使用 Entity Framework Core 8，其性能在 .NET 8 中有显著提升：

```csharp
public sealed class EfDocumentRepository : IDocumentRepository
{
    private readonly AppDbContext _context;
    public EfDocumentRepository(AppDbContext context) => _context = context;

    public async Task<Document?> GetByIdAsync(
        Guid id,
        CancellationToken ct = default)
    {
        return await _context.Documents
            .Include(d => d.Tags)
            .FirstOrDefaultAsync(d => d.Id == id, ct);
    }

    public async Task<IReadOnlyList<Document>> GetByCategoryAsync(
        string category,
        int page,
        int pageSize,
        CancellationToken ct = default)
    {
        return await _context.Documents
            .AsNoTracking() // 只读查询，禁用变更跟踪，性能提升 50%+
            .Where(d => d.Category == category)
            .OrderByDescending(d => d.ModifiedAt)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(ct);
    }

    public void Add(Document document) => _context.Documents.Add(document);
    public void Update(Document document) => _context.Documents.Update(document);
    public void Remove(Document document) => _context.Documents.Remove(document);
}
```

注意 AsNoTracking() 的合理使用——只读查询禁用变更追踪可提升 20-40% 性能。写操作保持默认追踪以支持领域对象的变更检测。

**外部服务客户端** 应封装 HTTP 调用细节，提供领域友好的接口，并处理重试、熔断、日志等横切关注点：

```csharp
public interface IEmailNotificationService
{
    Task SendAsync(EmailMessage message, CancellationToken ct = default);
}

public sealed class SendGridEmailService : IEmailNotificationService
{
    private readonly ISendGridClient _client;
    private readonly ILogger<SendGridEmailService> _logger;

    public SendGridEmailService(
        ISendGridClient client,
        ILogger<SendGridEmailService> logger)
    {
        _client = client;
        _logger = logger;
    }

    public async Task SendAsync(EmailMessage message, CancellationToken ct = default)
    {
        var msg = new SendGridMessage
        {
            From = new EmailAddress(message.From.Address, message.From.Name),
            Subject = message.Subject,
            HtmlContent = message.BodyHtml
        };
        msg.AddTo(new EmailAddress(message.To.Address, message.To.Name));

        var response = await _client.SendEmailAsync(msg, ct);
        if (!response.IsSuccessStatusCode)
        {
            var error = await response.Body.ReadAsStringAsync(ct);
            _logger.LogError("Email sending failed: {StatusCode}, {Error}",
                response.StatusCode, error);
            throw new NotificationException(
                $"Email sending failed: {response.StatusCode}");
        }

        _logger.LogInformation("Email sent: {MessageId} to {Recipient}",
            response.Headers.GetValues("X-Message-Id").FirstOrDefault(),
            message.To.Address);
    }
}
```

### 2.2 项目物理结构

#### 2.2.1 解决方案组织：按功能垂直切片 vs 按技术水平分层

.NET 解决方案的物理组织有两种主流模式，对于 WebView2 桌面应用，**垂直切片（Vertical Slicing）** 通常是更优选择：

| 组织模式 | 结构示例 | 优势 | 劣势 | AI 友好度 |
| --- | --- | --- | --- | --- |
| **水平分层** | MyApp.Domain/Entities/User.cs + MyApp.Application/Services/UserService.cs | 架构边界清晰，基础设施复用简单 | 功能代码分散，大型项目导航困难 | ⭐⭐⭐ |
| **垂直切片** | MyApp.Features.Users/GetUserById/GetUserByIdEndpoint.cs + GetUserByIdHandler.cs | 功能内聚高，修改影响范围局部化 | 跨功能共享需设计，学习曲线陡峭 | ⭐⭐⭐⭐⭐ |
| **混合模式** | 核心领域水平分层，外围功能垂直切片 | 兼顾两者优势 | 架构复杂度较高 | ⭐⭐⭐⭐⭐ |

**垂直切片架构** 的核心思想是将功能相关的所有代码——从端点定义、应用逻辑、领域模型到数据访问——组织于同一项目或同一文件夹内。每个切片是自包含的、可独立理解的功能单元。这种组织方式在 AI 辅助开发环境下尤为高效——AI 工具可以基于领域需求一次性生成完整的切片代码，而非分散在多个文件夹中的碎片代码。

对于桌面应用项目，推荐采用**混合方案**：核心领域模型和共享契约保持在独立项目（MyApp.Core、MyApp.Contracts），确保跨切片的复用与稳定性；功能切片以文件夹形式组织于主服务项目（MyApp.Host）内，每个切片包含该功能的所有技术层实现。

#### 2.2.2 项目命名规范

| 项目类型 | 命名模式 | 示例 | 职责说明 |
| --- | --- | --- | --- |
| 宿主应用 | {Company}.{Product}.Host 或 .Desktop | Acme.Crm.Desktop | WinForms + WebView2 宿主，应用入口 |
| API 层（若分离） | {Company}.{Product}.API | Acme.Crm.API | Minimal APIs 或 Controllers |
| 应用层 | {Company}.{Product}.Application | Acme.Crm.Application | 用例服务、DTOs、验证规则 |
| 领域层 | {Company}.{Product}.Domain 或 .Core | Acme.Crm.Domain | 实体、值对象、领域服务 |
| 基础设施层 | {Company}.{Product}.Infrastructure | Acme.Crm.Infrastructure | EF Core、外部服务、文件存储 |
| 共享契约 | {Company}.{Product}.Contracts | Acme.Crm.Contracts | 前后端共享的 API 契约 |
| 测试项目 | {Company}.{Product}.{Target}.Tests | Acme.Crm.Domain.Tests | 对应目标项目的单元/集成测试 |

命名空间应与项目结构保持一致，采用反向域名风格，如 Acme.Crm.Domain.Orders。避免过深的命名空间嵌套（建议不超过 4 层），必要时使用文件夹组织而非额外命名空间层次。

#### 2.2.3 共享库设计

**MyApp.Contracts** 是前后端共享的 API 契约，这是实现类型安全通信的关键。使用 .NET 的 Source Generators 可以自动生成 TypeScript 类型定义：

```csharp
// Contracts 项目（.NET 类库，最小依赖）
namespace Acme.Crm.Contracts;

[GenerateTypeScript] // 自定义 Source Generator 属性
public sealed record DocumentDto(
    Guid Id,
    string Title,
    DocumentStatus Status,
    DateTimeOffset ModifiedAt
);

// 生成的 TypeScript（编译时）
// interface DocumentDto {
//   id: string;
//   title: string;
//   status: DocumentStatus;
//   modifiedAt: string; // ISO 8601
// }
```

**MyApp.Common** 包含真正的通用工具，但应严格控制其范围，避免成为"垃圾堆"：

* ✅ **合适的内容**：扩展方法、结果类型（Result<T>）、guard clauses、时间/ID 抽象
* ❌ **避免的内容**：业务逻辑、框架特定的代码、频繁变更的代码

### 2.3 C# 12 特性应用

#### 2.3.1 不可变数据设计：record、required、init-only properties

C# 12 强化了不可变数据的设计能力，这对于领域建模和 API 契约尤为重要：

```csharp
// 完整不可变的领域事件
public sealed record OrderCreatedEvent(
    required Guid OrderId,
    required Guid CustomerId,
    required DateTimeOffset OccurredAt,
    required IReadOnlyList<OrderLineItem> Items
) : IDomainEvent;

// 可选参数的合理默认值
public sealed record PaginationOptions(
    int PageNumber = 1,
    int PageSize = 20,
    string? SortBy = null,
    bool Descending = false
);
```

required 成员确保对象在构造时即处于有效状态，编译器会验证所有 required 属性是否被赋值：

```csharp
// 编译错误：缺少 required 成员赋值
var config = new AppConfiguration { MaxRetryAttempts = 3 };

// 正确：使用对象初始化器完整赋值
var config = new AppConfiguration
{
    DatabaseConnectionString = "Server=...",
    MaxRetryAttempts = 3
    // CommandTimeout 使用默认值，非 required 可省略
};
```

#### 2.3.2 集合表达式与模式匹配简化代码

C# 12 的集合表达式提供了统一、简洁的集合初始化语法：

```csharp
// 旧语法
int[] array = new[] { 1, 2, 3 };
List<string> list = new List<string> { "Alice", "Bob" };
Span<int> span = stackalloc int[] { 1, 2, 3 };

// C# 12 集合表达式
int[] array = [1, 2, 3];
List<string> names = ["Alice", "Bob"];
Span<int> span = [1, 2, 3];

// 展开操作符
int[] moreNumbers = [..array, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]
```

模式匹配在 C# 12 中进一步增强，列表模式支持对集合结构的声明式匹配：

```csharp
// 列表模式匹配
public decimal CalculateDiscount(Order order) => order.Items switch
{
    [] => 0,                                    // 空订单
    [var single] => single.LineTotal * 0.05m,   // 单商品 5% 折扣
    [_, _, ..] => order.TotalAmount * 0.10m,    // 多商品 10% 折扣
    _ => 0
};

// 属性模式与关系模式结合
bool IsEligibleForFreeShipping(Order order) => order switch
{
    { Status: OrderStatus.Confirmed, TotalAmount.Amount: > 1000 } => true,
    { Customer.IsVip: true } => true,
    _ => false
};
```

#### 2.3.3 主构造函数与文件作用域类型优化结构

**主构造函数** 将构造函数参数直接声明在类/结构体定义中，编译器自动生成相应的字段和赋值：

```csharp
// C# 12 之前
public class OrderService
{
    private readonly IOrderRepository _repository;
    private readonly IEventBus _eventBus;
    private readonly ILogger<OrderService> _logger;

    public OrderService(
        IOrderRepository repository,
        IEventBus eventBus,
        ILogger<OrderService> logger)
    {
        _repository = repository;
        _eventBus = eventBus;
        _logger = logger;
    }
}

// C# 12 主构造函数
public class OrderService(
    IOrderRepository repository,
    IEventBus eventBus,
    ILogger<OrderService> logger)
{
    public async Task<Order?> GetByIdAsync(Guid id, CancellationToken ct)
    {
        logger.LogInformation("Getting order {OrderId}", id);
        // 直接使用 repository, eventBus, logger
        return await repository.GetByIdAsync(id, ct);
    }
}
```

**文件作用域类型** 通过 file 修饰符将类型的可见性限制在单个文件内：

```csharp
// OrderService.cs
file sealed class OrderValidationRules // 仅当前文件可见
{
    public const int MaxItemsPerOrder = 100;
    public const decimal MaxOrderAmount = 100_000m;
}

public class OrderService { /* 可在内部使用 OrderValidationRules */ }
```

#### 2.3.4 内联数组与Span性能优化场景

**内联数组** 允许在结构体中定义固定大小的数组，栈分配避免堆压力和 GC：

```csharp
[System.Runtime.CompilerServices.InlineArray(10)]
public struct Buffer10<T>
{
    private T _element0; // 编译器生成 10 个元素的连续存储
}

// 使用：栈上分配，无 GC 压力
Buffer10<byte> buffer = new();
Span<byte> span = buffer; // 隐式转换
span.Fill(0xFF);
```

Span<T> 和 Memory<T> 是 .NET 高性能编程的基础，配合集合表达式提供高效的内存操作：

```csharp
// 高效的字符串前缀检查
ReadOnlySpan<byte> pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
bool IsPng(ReadOnlySpan<byte> data) =>
    data.Length >= pngSignature.Length &&
    data[..pngSignature.Length].SequenceEqual(pngSignature);
```

### 2.4 依赖注入与服务注册

#### 2.4.1 原生DI容器最佳实践

.NET 8 的原生 DI 容器功能完备，对于大多数场景无需引入第三方容器。服务注册应集中管理，推荐按功能模块组织：

```csharp
// Program.cs
builder.Services
    .AddDomainServices()
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWebView2Integration();

// 扩展方法组织
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddApplicationServices(
        this IServiceCollection services)
    {
        services.AddScoped<IOrderService, OrderService>();
        services.AddScoped<IProductService, ProductService>();

        // 验证器
        services.AddValidatorsFromAssemblyContaining<Program>();

        // MediatR 行为管道
        services.AddTransient(typeof(IPipelineBehavior<,>),
            typeof(ValidationBehavior<,>));

        return services;
    }
}
```

#### 2.4.2 服务生命周期管理

| 生命周期 | 实例数 | 适用场景 | 注意事项 |
| --- | --- | --- | --- |
| **Singleton** | 整个应用 1 个 | 无状态服务、配置、缓存 | 线程安全必需；避免持有 Scoped 服务 |
| **Scoped** | 每请求/作用域 1 个 | 业务服务、DbContext、工作单元 | WebView2 中需手动创建作用域 |
| **Transient** | 每次解析新建 | 轻量级无状态服务、工厂 | 避免在热路径过度使用 |

**关键陷阱**：Singleton 服务注入 Scoped 服务会导致"captive dependency"——Scoped 服务被意外延长生命周期，引发并发问题。解决方案是使用 IServiceScopeFactory 显式创建作用域：

```csharp
public class BackgroundProcessor : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    public BackgroundProcessor(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            using var scope = _scopeFactory.CreateScope();
            var repository = scope.ServiceProvider
                .GetRequiredService<IOrderRepository>();
            // 使用 repository...
            await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
        }
    }
}
```

#### 2.4.3 选项模式（Options Pattern）配置管理

选项模式将配置强类型化，支持验证、变更通知和命名选项：

```csharp
// 定义选项类
public sealed class DatabaseOptions
{
    public const string SectionName = "Database";

    [Required]
    public required string ConnectionString { get; set; }

    [Range(1, 100)]
    public int MaxRetryCount { get; set; } = 3;

    public TimeSpan CommandTimeout { get; set; } = TimeSpan.FromSeconds(30);
}

// 注册和验证
builder.Services.AddOptions<DatabaseOptions>()
    .Bind(builder.Configuration.GetSection(DatabaseOptions.SectionName))
    .ValidateDataAnnotations()
    .ValidateOnStart(); // 启动时验证，尽早失败

// 使用
public class OrderRepository(
    DbContext Context,
    IOptions<DatabaseOptions> options) : IOrderRepository
{
    private readonly DatabaseOptions _options = options.Value;
    // 使用 _options.ConnectionString 等
}
```

## 3. 前端代码结构（WebView2 + HTML/JS）

### 3.1 前端架构模式

#### 3.1.1 单页应用（SPA）结构设计

WebView2 前端应采用现代 **SPA（单页应用）** 架构，通过客户端路由实现视图切换，避免页面刷新带来的体验中断。与浏览器环境的关键差异：

| 维度 | 浏览器 SPA | WebView2 SPA |
| --- | --- | --- |
| **路由** | URL 路径 + History API | 内存状态管理，可选虚拟路由 |
| **存储** | localStorage / IndexedDB | 宿主应用提供的持久化 API |
| **网络** | 远程 HTTP 请求为主 | 本地通信为主，可选远程同步 |
| **更新** | 页面刷新或 HMR | 热重载、运行时代码推送 |
| **多窗口** | 浏览器标签/窗口 | 宿主控制的多个 WebView2 实例 |

推荐的 SPA 结构采用基于模块的组件系统，而非框架锁定：

```
src/
├── core/                    # 核心基础设施
│   ├── messaging/           # WebMessage / HTTP 客户端
│   ├── state/               # 轻量级状态管理
│   ├── router/              # 虚拟路由（可选）
│   └── di/                  # 依赖注入容器
├── features/                # 功能模块（与后端垂直切片对应）
│   ├── documents/           # 文档功能
│   │   ├── components/      # UI 组件
│   │   ├── services/        # 领域服务
│   │   ├── stores/          # 状态存储
│   │   └── index.ts         # 模块导出
│   ├── settings/
│   └── search/
├── shared/                  # 共享资源
│   ├── components/          # 通用 UI 组件
│   ├── utils/               # 工具函数
│   └── types/               # TypeScript 类型（从 C# 生成）
└── main.ts                  # 应用入口
```

#### 3.1.2 组件化/模块化组织方式

采用原生 **Web Components** 或轻量级框架（如 Lit、Petite Vue），避免引入大型框架的 runtime 开销。组件设计原则：

* **自包含**：每个组件管理自己的状态、样式和模板
* **声明式接口**：通过属性接收数据，通过事件输出变更
* **懒加载**：路由级组件动态导入，优化启动时间

```javascript
// 原生 Web Component 示例
class DocumentList extends HTMLElement {
    static observedAttributes = ['category', 'page-size'];
    #documents = [];
    #loading = false;
    #page = 1;

    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
    }

    async attributeChangedCallback(name, oldVal, newVal) {
        if (name === 'category' && newVal) {
            await this.#loadDocuments();
        }
    }

    async #loadDocuments() {
        this.#loading = true;
        this.#render();
        // 通过封装后的 API 客户端调用本地服务
        this.#documents = await apiClient.get('/api/documents', {
            category: this.getAttribute('category'),
            page: this.#page,
            pageSize: this.getAttribute('page-size') || 20
        });
        this.#loading = false;
        this.#render();
    }

    #render() {
        this.shadowRoot.innerHTML = `
            <style>:host { display: block; }</style>
            ${this.#loading
                ? '<loading-spinner></loading-spinner>'
                : `<div class="document-list">
                    ${this.#documents.map(d => `
                        <document-card .document=${d}></document-card>
                    `).join('')}
                   </div>
                   <pagination .currentPage=${this.#page}></pagination>`
            }
        `;
    }
}
customElements.define('document-list', DocumentList);
```

#### 3.1.3 状态管理策略

桌面应用的状态管理应当**分层设计**：

| 层级 | 范围 | 持久化 | 示例 |
| --- | --- | --- | --- |
| **全局状态** | 应用级共享 | 可选（用户偏好） | 当前用户、主题设置 |
| **功能状态** | 模块内共享 | 通常不持久化 | 文档列表过滤条件 |
| **组件状态** | 组件内部 | 不持久化 | 表单输入、展开状态 |
| **服务端状态** | 后端权威来源 | 后端持久化 | 文档内容、用户数据 |

轻量级状态管理实现（无需 Redux/Vuex）：

```javascript
// Signal 模式：细粒度响应式
class Signal {
    #value;
    #subscribers = new Set();

    constructor(initialValue) {
        this.#value = initialValue;
    }

    get value() { return this.#value; }

    set value(newValue) {
        if (Object.is(this.#value, newValue)) return;
        this.#value = newValue;
        this.#subscribers.forEach(cb => cb(newValue));
    }

    subscribe(callback) {
        this.#subscribers.add(callback);
        callback(this.#value); // 立即执行一次
        return () => this.#subscribers.delete(callback);
    }
}

// 使用
const documentStore = {
    documents: new Signal([]),
    selectedId: new Signal(null),

    async load(category) {
        const result = await api.getDocuments({ category });
        this.documents.value = result.items;
    },

    select(id) {
        this.selectedId.value = id;
    }
};

// 组件订阅
documentStore.documents.subscribe(docs => {
    renderDocumentList(docs);
});
```

### 3.2 项目目录组织

#### 3.2.1 静态资源层：wwwroot / assets / index.html

静态资源的组织应当支持**开发时热重载**和**生产环境嵌入**两种模式：

```
wwwroot/                   # 或 web/
├── index.html             # 应用入口
├── favicon.ico
├── assets/                # 构建产物（Git 忽略）
│   ├── main.[hash].js
│   ├── main.[hash].css
│   └── ...
└── static/                # 无需处理的静态资源
    ├── fonts/
    ├── images/
    └── locales/
```

index.html 模板需包含 WebView2 环境检测：

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyApp Desktop</title>
    <script>
        // WebView2 环境检测
        window.isWebView2 = typeof chrome !== 'undefined' && !!chrome.webview;
        window.isDev = location.protocol === 'http:';
        if (!window.isWebView2 && !window.isDev) {
            document.body.innerHTML = '<h1>请在 WebView2 环境中运行</h1>';
        }
    </script>
    <link rel="stylesheet" href="./assets/main.css">
</head>
<body>
    <div id="app"></div>
    <script type="module" src="./assets/main.js"></script>
</body>
</html>
```

#### 3.2.2 脚本层：src/modules / src/services / src/utils

TypeScript 源代码的详细组织：

```
src/
├── core/                    # 核心基础设施（稳定、少变更）
│   ├── messaging/
│   │   ├── webMessageClient.ts    # WebMessage 客户端封装
│   │   ├── httpClient.ts          # HTTP 客户端（fetch 封装）
│   │   ├── messageRouter.ts       # 消息路由分发
│   │   └── types.ts               # 通信类型定义
│   ├── state/
│   │   ├── signal.ts              # 响应式原语
│   │   ├── store.ts               # 状态存储基类
│   │   └── persistence.ts         # 持久化适配器
│   ├── di/
│   │   ├── container.ts           # DI 容器实现
│   │   └── tokens.ts              # 服务标识符
│   └── platform/
│       ├── webview2.ts            # WebView2 API 封装
│       ├── clipboard.ts           # 剪贴板抽象
│       └── fileSystem.ts          # 文件系统抽象
├── features/                # 业务功能（垂直切片）
│   └── [feature-name]/
│       ├── components/      # UI 组件
│       ├── services/        # 领域服务
│       ├── stores/          # 状态存储
│       └── index.ts         # 模块导出
├── shared/                  # 跨功能共享
│   ├── components/          # 通用 UI 组件
│   ├── styles/              # 主题、变量
│   └── utils/               # 纯函数工具
└── main.ts                  # 应用入口
```

#### 3.2.3 样式层：css/components / css/themes

采用 **CSS 自定义属性（变量）** 实现主题系统，支持运行时切换：

```css
/* themes/light.css */
:root {
    /* 基础色板 */
    --color-primary-hue: 220;
    --color-primary: hsl(var(--color-primary-hue) 80% 50%);
    --color-primary-light: hsl(var(--color-primary-hue) 80% 60%);
    --color-primary-dark: hsl(var(--color-primary-hue) 80% 40%);

    /* 语义颜色 */
    --surface-bg: #ffffff;
    --surface-fg: #1a1a1a;
    --border-color: #e0e0e0;

    /* 间距系统 */
    --spacing-unit: 0.25rem;
    --radius-base: 0.5rem;

    /* 阴影 */
    --shadow-elevation-1: 0 1px 3px rgba(0,0,0,0.1);
}

/* themes/dark.css */
[data-theme="dark"] {
    --surface-bg: #1a1a1a;
    --surface-fg: #f0f0f0;
    --border-color: #404040;
    --shadow-elevation-1: 0 1px 3px rgba(0,0,0,0.3);
}

/* components/button.css */
.btn {
    padding: calc(var(--spacing-unit) * 3) calc(var(--spacing-unit) * 4);
    border-radius: var(--radius-base);
    background: var(--color-primary);
    color: white;
    border: none;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
}
.btn:hover {
    transform: translateY(-1px);
    box-shadow: var(--shadow-elevation-1);
}
```

### 3.3 与宿主程序集成

#### 3.3.1 WebView2初始化与配置

完整的 WebView2 初始化流程：

```csharp
public class WebView2Host : IAsyncDisposable
{
    private readonly WebView2 _webView;
    private readonly ILogger<WebView2Host> _logger;
    private CoreWebView2Environment? _environment;
    private readonly WebView2Options _options;

    public WebView2Host(
        WebView2 webView,
        IOptions<WebView2Options> options,
        ILogger<WebView2Host> logger)
    {
        _webView = webView;
        _options = options.Value;
        _logger = logger;
    }

    public async Task InitializeAsync()
    {
        try
        {
            // 创建自定义环境，配置用户数据文件夹
            _environment = await CoreWebView2Environment.CreateAsync(
                browserExecutableFolder: null,
                userDataFolder: Path.Combine(
                    Environment.GetFolderPath(
                        Environment.SpecialFolder.LocalApplicationData),
                    _options.UserDataFolder),
                options: new CoreWebView2EnvironmentOptions
                {
                    AdditionalBrowserArguments =
                        $"--lang={_options.Language}",
                    AllowSingleSignOnUsingOSPrimaryAccount = true
                });

            // 确保 CoreWebView2 初始化完成
            await _webView.EnsureCoreWebView2Async(_environment);
            ConfigureWebView2();
            RegisterMessageHandlers();
            LoadInitialPage();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "WebView2 initialization failed");
            throw;
        }
    }

    private void ConfigureWebView2()
    {
        var core = _webView.CoreWebView2;

        // 开发工具配置
        core.Settings.AreDevToolsEnabled = _options.AllowDevTools;
        core.Settings.AreDefaultContextMenusEnabled = _options.AllowDevTools;

        // 安全策略
        if (_options.AllowedOrigins?.Length > 0)
        {
            core.AddWebResourceRequestedFilter(
                "*",
                CoreWebView2WebResourceContext.All);
            core.WebResourceRequested += (s, e) =>
            {
                var origin = new Uri(e.Request.Uri)
                    .GetLeftPart(UriPartial.Authority);
                if (!_options.AllowedOrigins.Contains(origin))
                {
                    e.Response = core.Environment.CreateWebResourceResponse(
                        Stream.Null, 403, "Forbidden",
                        "Content-Type: text/plain");
                }
            };
        }

        // 新窗口处理：强制在当前窗口打开
        core.NewWindowRequested += (s, e) =>
        {
            e.Handled = true;
            core.Navigate(e.Uri);
        };
    }

    private void RegisterMessageHandlers()
    {
        _webView.CoreWebView2.WebMessageReceived += OnWebMessageReceived;
    }

    private void OnWebMessageReceived(
        object? sender,
        CoreWebView2WebMessageReceivedEventArgs e)
    {
        try
        {
            var message = JsonSerializer.Deserialize<WebMessage>(
                e.WebMessageAsJson,
                new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });
            if (message is null) return;
            _ = HandleMessageAsync(message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to process web message: {RawMessage}",
                e.WebMessageAsJson);
        }
    }

    private void LoadInitialPage()
    {
        var indexPath = Path.Combine(
            AppContext.BaseDirectory,
            "wwwroot",
            "index.html");
        _webView.Source = new Uri(
            $"file:///{indexPath.Replace("\\", "/")}");
    }

    public async ValueTask DisposeAsync()
    {
        _webView?.Dispose();
        // 清理环境资源
    }
}
```

#### 3.3.2 本地资源加载策略（file:// vs embedded resource）

| 策略 | 实现方式 | 适用场景 | 优缺点 |
| --- | --- | --- | --- |
| **文件系统** | file:///{path}/index.html | 开发调试、需要热更新 | 简单，但路径处理复杂，安全性较低 |
| **嵌入资源** | res:// 协议或自定义虚拟主机 | 单文件发布、高安全性 | 打包简单，但更新需重新部署 |
| **混合模式** | 嵌入基础资源，动态下载更新 | 需要自动更新的生产应用 | 灵活性高，实现复杂 |

嵌入资源实现示例：

```csharp
// 注册虚拟主机映射
webView.CoreWebView2.SetVirtualHostNameToFolderMapping(
    "app.local",
    Path.Combine(AppContext.BaseDirectory, "wwwroot"),
    CoreWebView2HostResourceAccessKind.Allow);
webView.Source = new Uri("https://app.local/index.html");

// 或完全嵌入，通过拦截请求动态提供
webView.CoreWebView2.AddWebResourceRequestedFilter(
    "*",
    CoreWebView2WebResourceContext.All);
webView.CoreWebView2.WebResourceRequested += async (s, e) =>
{
    var resourceName = MapUrlToResourceName(e.Request.Uri);
    var stream = Assembly.GetExecutingAssembly()
        .GetManifestResourceStream(resourceName);
    if (stream != null)
    {
        e.Response = webView.CoreWebView2.Environment
            .CreateWebResourceResponse(
                stream, 200, "OK",
                $"Content-Type: {GetMimeType(resourceName)}");
    }
};
```

#### 3.3.3 开发时热重载与调试配置

利用 WebView2 的远程调试协议实现开发体验优化：

```csharp
// 启动时启用远程调试端口
var options = new CoreWebView2EnvironmentOptions
{
    AdditionalBrowserArguments = "--remote-debugging-port=9222"
};

// 开发配置
if (builder.Environment.IsDevelopment())
{
    // 自动打开 DevTools
    webView.CoreWebView2.OpenDevToolsWindow();
    // 或连接到 Vite 开发服务器
    webView.Source = new Uri("http://localhost:5173");
}
else
{
    // 生产环境：本地嵌入资源
    webView.Source = new Uri("https://app.local/index.html");
}
```

## 4. 前后端通信机制

### 4.1 通信协议设计

#### 4.1.1 WebMessage方式：PostMessage双向通信

WebMessage 是 WebView2 的原生通信机制，适合高频、低延迟的场景。完整实现包括消息封装、路由分发和类型安全：

**共享消息契约**（C# 定义，通过 Source Generator 生成 TypeScript）：

```csharp
public abstract record WebMessage(
    string Type,
    Guid CorrelationId)
{
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

public record ProgressNotification(
    string OperationId,
    int PercentComplete,
    string? Message = null
) : WebMessage("progress", Guid.NewGuid());

public record DataRequest<TPayload>(
    Guid CorrelationId,
    string Endpoint,
    TPayload? Payload = default
) : WebMessage("request", CorrelationId);

public record DataResponse<TData>(
    Guid CorrelationId,
    bool Success,
    TData? Data = default,
    string? Error = null
) : WebMessage("response", CorrelationId);
```

**C# 端消息处理器**：

```csharp
public interface IWebMessageHandler
{
    string MessageType { get; }
    Task HandleAsync(JsonElement payload, Guid correlationId);
}

public class WebMessageDispatcher(
    IEnumerable<IWebMessageHandler> handlers,
    ILogger<WebMessageDispatcher> logger)
{
    private readonly Dictionary<string, IWebMessageHandler> _handlers =
        handlers.ToDictionary(
            h => h.MessageType,
            StringComparer.OrdinalIgnoreCase);

    public async Task DispatchAsync(WebMessage message)
    {
        if (_handlers.TryGetValue(message.Type, out var handler))
        {
            await handler.HandleAsync(
                JsonSerializer.SerializeToElement(message),
                message.CorrelationId);
        }
        else
        {
            logger.LogWarning(
                "No handler registered for message type: {Type}",
                message.Type);
        }
    }
}
```

**JavaScript 端封装**：

```javascript
class WebMessageBridge {
    #handlers = new Map();
    #pendingRequests = new Map();
    #requestId = 0;

    constructor() {
        window.chrome.webview?.addEventListener(
            'message',
            (e) => this.#onMessage(e.data));
    }

    // 发送通知（无需响应）
    notify(type, payload) {
        window.chrome.webview?.postMessage({
            type,
            payload,
            timestamp: Date.now()
        });
    }

    // 发送请求，返回 Promise
    async request(type, payload, timeoutMs = 30000) {
        const correlationId = ++this.#requestId;
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this.#pendingRequests.delete(correlationId);
                reject(new Error(
                    `Request ${type} timed out after ${timeoutMs}ms`));
            }, timeoutMs);

            this.#pendingRequests.set(correlationId,
                { resolve, reject, timeout });

            window.chrome.webview?.postMessage({
                type,
                payload,
                correlationId,
                timestamp: Date.now()
            });
        });
    }

    // 注册消息处理器
    on(type, handler) {
        if (!this.#handlers.has(type)) {
            this.#handlers.set(type, new Set());
        }
        this.#handlers.get(type).add(handler);
        return () => this.#handlers.get(type).delete(handler);
    }

    #onMessage(message) {
        // 处理响应
        if (message.correlationId &&
            this.#pendingRequests.has(message.correlationId)) {
            const { resolve, reject, timeout } =
                this.#pendingRequests.get(message.correlationId);
            clearTimeout(timeout);
            this.#pendingRequests.delete(message.correlationId);
            message.success
                ? resolve(message.data)
                : reject(new Error(message.error));
            return;
        }

        // 处理通知
        const handlers = this.#handlers.get(message.type);
        handlers?.forEach(h => {
            try { h(message.payload); }
            catch (e) { console.error(e); }
        });
    }
}
export const bridge = new WebMessageBridge();
```

#### 4.1.2 HTTP API方式：本地Kestrel服务端点

对于复杂的数据操作，HTTP API 提供更标准的语义和更好的工具支持：

```csharp
var builder = WebApplication.CreateBuilder(args);

// 仅绑定本地回环，拒绝外部连接
builder.WebHost.ConfigureKestrel(options =>
{
    options.ListenLocalhost(0); // 动态分配端口
    options.ListenLocalhost(0,
        listenOptions => listenOptions.UseHttps());
});

var app = builder.Build();

// CORS：仅允许 WebView2 来源
app.UseCors(policy => policy
    .WithOrigins("file://", "app://", "https://localhost:*")
    .AllowAnyMethod()
    .AllowAnyHeader());

// 健康检查
app.MapGet("/health", () => Results.Ok(new { Status = "Healthy" }));

// API 端点...
```

前端 HTTP 客户端封装，自动发现本地服务端点：

```javascript
class LocalHttpClient {
    #baseUrl = null;
    #discovering = null;

    async #discoverEndpoint() {
        // 尝试常见端口，或从 WebMessage 获取
        const candidates = [
            'https://localhost:5002',
            'http://localhost:5001'
        ];
        for (const url of candidates) {
            try {
                const response = await fetch(`${url}/health`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(1000)
                });
                if (response.ok) {
                    this.#baseUrl = url;
                    return url;
                }
            } catch { /* 继续尝试 */ }
        }
        // 通过 WebMessage 请求后端告知端口
        const { httpPort, httpsPort } =
            await bridge.request('get-endpoint-info');
        this.#baseUrl = `https://localhost:${httpsPort}`;
        return this.#baseUrl;
    }

    async request(path, options = {}) {
        if (!this.#baseUrl) {
            await (this.#discovering ??= this.#discoverEndpoint());
        }
        const url = `${this.#baseUrl}${path}`;
        const response = await fetch(url, {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'WebView2',
                ...options.headers
            }
        });
        if (!response.ok) {
            const error = await response.text();
            throw new ApiError(response.status, error);
        }
        return response.json();
    }

    get(path) {
        return this.request(path, { method: 'GET' });
    }

    post(path, body) {
        return this.request(path, {
            method: 'POST',
            body: JSON.stringify(body)
        });
    }
}
export const apiClient = new LocalHttpClient();
```

#### 4.1.3 混合模式：实时通知+数据查询分离

| 场景 | 推荐机制 | 理由 |
| --- | --- | --- |
| **CRUD 数据操作、复杂查询** | HTTP API | 标准语义、缓存友好、易于调试 |
| **实时通知、状态变更推送** | WebMessage | 低延迟、服务器主动推送 |
| **文件上传/下载** | HTTP API | 流式处理、进度追踪 |
| **用户交互反馈** | WebMessage | 即时响应 |
| **长时间运行的操作** | WebMessage 进度 + HTTP 结果查询 | 实时反馈 + 可靠交付 |

### 4.2 消息契约与序列化

#### 4.2.1 统一消息格式：{ type, payload, correlationId }

统一的消息格式简化处理逻辑并支持横切关注点：

```typescript
interface Message<T = unknown> {
    type: string;                    // 消息类型，如 'orders:create'
    version: number;                 // 契约版本，支持演进
    payload: T;                      // 类型化的负载数据
    correlationId: string;           // 用于请求-响应关联
    timestamp: number;               // 客户端时间戳
    metadata?: Record<string, unknown>; // 扩展信息
}
```

#### 4.2.2 JSON序列化配置：System.Text.Json优化

System.Text.Json 在 .NET 8 中性能显著提升，是默认选择。优化配置：

```csharp
var options = new JsonSerializerOptions
{
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
    NumberHandling = JsonNumberHandling.AllowReadingFromString,
    Converters =
    {
        new JsonStringEnumConverter(),
        new DateTimeOffsetConverter()
    }
};

// 源生成器支持 AOT 友好
[JsonSerializable(typeof(CreateDocumentCommand))]
[JsonSerializable(typeof(DocumentDto))]
internal partial class AppJsonContext : JsonSerializerContext { }
```

#### 4.2.3 类型安全：共享契约定义（Source Generators）

前后端类型安全通过共享契约定义实现。C# 源生成器可以从类型定义生成 TypeScript 接口：

```csharp
// C# 定义
[GenerateTypeScript]
public sealed record DocumentDto(
    Guid Id,
    string Title,
    DocumentStatus Status,
    DateTimeOffset ModifiedAt
);

// 生成的 TypeScript
interface DocumentDto {
    id: string;
    title: string;
    status: DocumentStatus;
    modifiedAt: string; // ISO 8601
}

enum DocumentStatus {
    Draft = 0,
    Published = 1,
    Archived = 2
}
```

### 4.3 错误处理与超时机制

#### 4.3.1 通信异常分类与重试策略

通信异常应分类处理，每类错误有不同的重试策略：

| 异常类型 | 特征 | 重试策略 | 示例 |
| --- | --- | --- | --- |
| **瞬时网络错误** | 连接失败、超时、重置 | 指数退避，最多 3 次 | HttpRequestException |
| **服务端错误** | 5xx 状态码 | 立即重试 1 次，然后降级 | 500 Internal Server Error |
| **客户端错误** | 4xx 状态码 | 不重试，立即失败 | 400 Bad Request |
| **业务规则错误** | 验证失败、状态冲突 | 不重试，提示用户 | DomainException |

Polly 库提供全面的弹性策略支持：

```csharp
services.AddHttpClient<IDocumentService, DocumentServiceClient>()
    .AddTransientHttpErrorPolicy(p =>
        p.WaitAndRetryAsync(3, retryAttempt =>
            TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))))
    .AddPolicyHandler(GetCircuitBreakerPolicy());
```

#### 4.3.2 进度反馈与取消令牌传播

长时间操作应支持进度反馈和取消：

```csharp
// 后端：可取消的异步操作
public async Task<Guid> ImportDocumentsAsync(
    Stream fileStream,
    IProgress<ImportProgress> progress,
    CancellationToken ct)
{
    var total = await CountLinesAsync(fileStream, ct);
    var processed = 0;

    await foreach (var document in ParseAsync(fileStream, ct))
    {
        ct.ThrowIfCancellationRequested();
        await _repository.AddAsync(document, ct);
        processed++;
        progress.Report(new ImportProgress(
            processed,
            total,
            $"Processed {document.Title}"));
    }

    return await _unitOfWork.SaveChangesAsync(ct);
}

// 前端：通过 WebMessage 接收进度
bridge.on('import:progress', (progress) => {
    updateProgressBar(progress.percentComplete, progress.message);
});
```

## 5. AI辅助开发工作流

### 5.1 代码生成策略

#### 5.1.1 领域模型与DTO批量生成

AI IDE 可以从领域描述或数据库模式生成完整的领域模型。有效的提示工程包括：提供现有代码示例作为风格参考、明确指定 C# 12 特性使用（record、required、主构造函数）、以及定义验证规则和领域方法签名。

**提示模板示例**：

```
基于以下业务需求生成 C# 12 领域模型：

需求：订单管理系统需要支持订单创建、状态流转（Draft -> Confirmed -> Shipped -> Delivered）、订单项管理、折扣计算。

约束：
- 使用 record 类型定义值对象（Money、Address）
- 实体使用 required 成员和 init-only 属性
- 主构造函数简化依赖注入
- 封装业务规则于领域方法中
- 添加适当的领域事件

生成内容：
1. Order 实体（含状态机）
2. OrderLine 值对象
3. Money 值对象（支持货币运算）
4. 相关领域事件
```

#### 5.1.2 样板代码自动化（Repository、Service模板）

重复性代码模式是 AI 辅助的理想目标。为每个实体生成仓储接口和实现、应用服务、以及对应的 API 端点，可以基于模板配置定制命名约定、基类和横切行为。

**代码生成模板结构**：

| 模板类型 | 输入 | 输出 | 自定义点 |
| --- | --- | --- | --- |
| **实体模板** | 实体名称、属性列表 | 实体类、值对象、领域事件 | 基类、验证规则、事件类型 |
| **仓储模板** | 实体名称 | 接口、EF Core 实现 | 查询方法、包含策略、分页 |
| **服务模板** | 实体名称、操作列表 | 应用服务、命令/查询处理器 | 事务边界、缓存策略、日志 |
| **API 模板** | 服务名称、端点列表 | Minimal API 端点、DTO | 路由前缀、授权策略、响应格式 |

#### 5.1.3 单元测试用例生成

AI 可以从实现代码生成测试用例，覆盖正常路径、边界条件和错误场景。有效的测试生成需要：提供测试框架配置（xUnit、NSubstitute、FluentAssertions）、现有测试作为风格示例、以及明确的覆盖率目标。

**测试生成提示模板**：

```
为以下 Order.Create 工厂方法生成单元测试：

代码：
public static Order Create(string title, string content, string? category)

测试要求：
- 使用 xUnit + NSubstitute + FluentAssertions
- 覆盖：有效输入、空标题、超长标题、null 内容
- 验证：返回实体属性、抛出异常类型、领域事件发布
- 命名规范：MethodName_Scenario_ExpectedResult
```

### 5.2 代码审查与重构

#### 5.2.1 架构约束自动化检查

AI 可以辅助执行架构约束，识别潜在违规：

| 检查项 | 检测模式 | 自动修复建议 |
| --- | --- | --- |
| 分层依赖违规 | 领域层引用基础设施类型 | 提取接口，依赖倒置 |
| 服务生命周期错误 | Singleton 依赖 Scoped 服务 | 使用 IServiceScopeFactory |
| 异步模式不一致 | 同步阻塞调用（.Result, .Wait()） | 改为 await，传播 async |
| 空引用风险 | 未检查的可空类型解引用 | 添加 null 检查或空合并 |
| 资源泄漏 | 未释放的 IDisposable | 添加 using 或实现 IAsyncDisposable |

#### 5.2.2 命名规范与代码风格一致性

AI 可以学习项目的特定风格，并在生成和重构中应用。EditorConfig 和 .editorconfig 文件提供可机读的规则定义，AI 工具可以据此调整格式化行为。

**命名规范矩阵**：

| 元素类型 | 命名约定 | 示例 |
| --- | --- | --- |
| 类型（类、结构、接口、枚举、委托） | PascalCase | OrderService, IRepository<T> |
| 类型成员（方法、属性、事件） | PascalCase | GetByIdAsync, TotalAmount |
| 局部变量、参数 | camelCase | customerId, request |
| 私有字段 | _camelCase | _repository, _logger |
| 常量（所有作用域） | PascalCase | MaxRetryCount |
| 静态只读字段 | PascalCase | DefaultInstance |

#### 5.2.3 技术债务识别与重构建议

AI 可以识别代码库中的技术债务模式：

* **代码异味**：过长方法（>50 行）、过深嵌套（>4 层）、过大类（>500 行）、重复代码块
* **架构漂移**：分层边界模糊、领域逻辑泄漏到应用层、基础设施代码直接调用
* **性能陷阱**：N+1 查询、未使用 AsNoTracking、同步阻塞、过度分配
* **可维护性问题**：魔法字符串、硬编码配置、缺失 XML 文档、未处理的异常

### 5.3 文档与注释维护

#### 5.3.1 XML文档自动生成与同步

AI 可以从实现代码推断 XML 文档注释，保持文档与代码同步：

```csharp
/// <summary>
/// 创建新订单。
/// </summary>
/// <param name="customerId">客户唯一标识。</param>
/// <param name="items">订单商品列表，至少包含一项。</param>
/// <param name="couponCode">可选的优惠码。</param>
/// <returns>新创建订单的唯一标识。</returns>
/// <exception cref="ValidationException">当输入参数无效时抛出。</exception>
/// <exception cref="DomainException">当业务规则冲突时抛出。</exception>
public async Task<Guid> CreateAsync(
    Guid customerId,
    IReadOnlyList<OrderItemDto> items,
    string? couponCode = null)
```

#### 5.3.2 架构决策记录（ADR）维护

AI 可以辅助生成和维护架构决策记录，确保设计意图的可追溯性：

```markdown
# ADR 001: 通信机制选择

## 状态
已接受

## 背景
需要为 WebView2 桌面应用选择前后端通信机制。

## 决策
采用混合模式：HTTP API 用于数据查询和 CRUD，WebMessage 用于实时通知和进度反馈。

## 后果
- 正面：兼顾性能与灵活性，HTTP API 易于测试和文档化，WebMessage 提供低延迟推送
- 负面：需要维护两套通信基础设施，前端代码复杂度增加

## 替代方案
- 纯 HTTP API：延迟较高，不适合实时场景
- 纯 WebMessage：缺乏标准工具支持，复杂查询实现困难
```

## 6. 开发流程与质量保证

### 6.1 测试驱动开发（TDD）

#### 6.1.1 单元测试：xUnit + NSubstitute + FluentAssertions

单元测试是质量保障的基础防线。推荐组合：

| 组件 | 用途 | 关键特性 |
| --- | --- | --- |
| **xUnit** | 测试框架 | 并行执行、无共享状态、丰富的断言 |
| **NSubstitute** | 模拟框架 | 可读 API、自动虚拟成员、参数匹配 |
| **FluentAssertions** | 断言库 | 流畅语法、详细失败消息、集合/异常支持 |

单元测试组织原则：被测系统对应测试类，测试方法命名完整描述场景。

```csharp
public class OrderServiceTests
{
    private readonly IOrderRepository _repository = Substitute.For<IOrderRepository>();
    private readonly IEventBus _eventBus = Substitute.For<IEventBus>();
    private readonly OrderService _sut;

    public OrderServiceTests()
    {
        _sut = new OrderService(
            _repository,
            _eventBus,
            Substitute.For<ILogger<OrderService>>());
    }

    [Fact]
    public async Task CreateAsync_WithValidRequest_ReturnsCreatedOrderId()
    {
        // Arrange
        var request = new CreateOrderCommand(
            Guid.NewGuid(),
            [new OrderItemDto(Guid.NewGuid(), 2, 100m)]);

        // Act
        var result = await _sut.CreateAsync(request);

        // Assert
        result.Should().NotBeEmpty();
        await _repository.Received().AddAsync(
            Arg.Is<Order>(o => o.Lines.Count == 1),
            Arg.Any<CancellationToken>());
        await _eventBus.Received().PublishAsync(
            Arg.Any<OrderCreatedEvent>(),
            Arg.Any<CancellationToken>());
    }

    [Fact]
    public async Task CreateAsync_WithEmptyItems_ThrowsValidationException()
    {
        // Arrange
        var request = new CreateOrderCommand(Guid.NewGuid(), []);

        // Act & Assert
        await Assert.ThrowsAsync<ValidationException>(
            () => _sut.CreateAsync(request));
    }
}
```

#### 6.1.2 集成测试：WebApplicationFactory + TestServer

集成测试验证组件间的协作行为。WebApplicationFactory<T> 在内存中启动完整的应用主机：

```csharp
public class CustomWebApplicationFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(services =>
        {
            // 替换为内存数据库
            services.RemoveAll<DbContextOptions<AppDbContext>>();
            services.AddDbContext<AppDbContext>(options =>
                options.UseInMemoryDatabase("TestDb"));

            // 替换外部服务为模拟实现
            services.AddSingleton<IEmailService, FakeEmailService>();
        });
    }
}

public class DocumentApiTests : IClassFixture<CustomWebApplicationFactory>
{
    private readonly HttpClient _client;

    public DocumentApiTests(CustomWebApplicationFactory factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task GetDocument_ReturnsOkWithDocument()
    {
        // Arrange: 通过 API 创建测试数据
        var createResponse = await _client.PostAsJsonAsync(
            "/api/documents",
            new { title = "Test", content = "Content" });
        var createdId = (await createResponse.Content
            .ReadFromJsonAsync<DocumentCreatedResponse>())!.Id;

        // Act
        var response = await _client.GetAsync($"/api/documents/{createdId}");

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.OK);
        var document = await response.Content.ReadFromJsonAsync<DocumentDto>();
        document!.Title.Should().Be("Test");
    }
}
```

#### 6.1.3 UI自动化测试：Playwright for WebView2

WebView2 的 UI 测试需要特殊配置。Microsoft 提供 Playwright 的实验性支持，通过 CDP（Chrome DevTools Protocol）与 WebView2 实例通信：

```csharp
// 启动 WebView2 并获取调试端口
var webView = new WebView2();
await webView.EnsureCoreWebView2Async();
var cdpPort = await webView.CoreWebView2
    .GetDevToolsProtocolHelper()
    .Browser.GetVersionAsync();

// 使用 Playwright 连接
var playwright = await Playwright.CreateAsync();
var browser = await playwright.Chromium.ConnectOverCDPAsync(
    $"http://localhost:{cdpPort}");

// 执行测试
var page = browser.Contexts[0].Pages[0];
await page.ClickAsync("[data-testid='create-document-button']");
await page.FillAsync("[data-testid='title-input']", "Test Document");
await page.ClickAsync("[data-testid='submit-button']");
var successMessage = await page.TextContentAsync("[data-testid='success-toast']");
successMessage.Should().Contain("created successfully");
```

### 6.2 代码规范体系

#### 6.2.1 命名约定：PascalCase/camelCase/_camelCase规范矩阵

| 元素类型 | 命名约定 | 示例 |
| --- | --- | --- |
| 类型（类、结构、接口、枚举、委托） | PascalCase | OrderService, IRepository<T> |
| 类型成员（方法、属性、事件） | PascalCase | GetByIdAsync, TotalAmount |
| 局部变量、参数 | camelCase | customerId, request |
| 私有字段 | _camelCase | _repository, _logger |
| 常量（所有作用域） | PascalCase | MaxRetryCount |
| 静态只读字段 | PascalCase | DefaultInstance |

#### 6.2.2 代码分析：EditorConfig + .NET Analyzers + StyleCop

```ini
# .editorconfig
[*.cs]
# 格式规则
indent_size = 4
insert_final_newline = true

# 代码分析规则
dotnet_diagnostic.CA1822.severity = warning    # 标记可静态化的成员
dotnet_diagnostic.CA1806.severity = error      # 不要忽略方法返回值
dotnet_diagnostic.CA2007.severity = none       # 不强制 ConfigureAwait
dotnet_diagnostic.CA1062.severity = warning    # 验证公共方法的参数

# StyleCop 规则
dotnet_diagnostic.SA1633.severity = none       # 文件头文档（可选）
dotnet_diagnostic.SA1200.severity = error      # using 语句必须在命名空间内
```

#### 6.2.3 提交规范：Conventional Commits + Git Hooks

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

| 类型 | 用途 | 示例 |
| --- | --- | --- |
| feat | 新功能 | feat(orders): add bulk create endpoint |
| fix | 缺陷修复 | fix(auth): resolve token refresh race condition |
| docs | 文档变更 | docs(api): update OpenAPI spec for v2 |
| style | 格式调整（不影响功能） | style: fix indentation in OrderService |
| refactor | 重构（不添加功能或修复） | refactor(domain): extract OrderStatus state machine |
| perf | 性能优化 | perf(queries): add covering index for document search |
| test | 测试相关 | test(integration): add WebView2 startup tests |
| chore | 构建/工具变更 | chore(deps): upgrade to .NET 8.0.2 |

Git Hooks 配置（使用 husky.net）：

```json
// .husky/task-runner.json
{
    "tasks": {
        "pre-commit": {
            "command": "dotnet format --verify-no-changes && dotnet build --no-restore"
        },
        "commit-msg": {
            "command": "dotnet husky run --name commit-lint --args \"${args}\""
        }
    }
}
```

### 6.3 持续集成/持续部署

#### 6.3.1 构建流水线：编译、测试、打包、签名

```yaml
# azure-pipelines.yml 或 github-actions.yml
stages:
- stage: Build
  jobs:
  - job: CompileAndTest
    steps:
    - task: UseDotNet@2
      inputs:
        version: '8.0.x'
    - script: dotnet restore
    - script: dotnet build --configuration Release --no-restore
    - script: dotnet test --no-build --verbosity normal
    - script: dotnet publish \
        --configuration Release \
        --runtime win-x64 \
        --self-contained true \
        -p:PublishSingleFile=true \
        -p:IncludeNativeLibrariesForSelfExtract=true \
        -o $(Build.ArtifactStagingDirectory)
    - task: CodeSigning@2
      inputs:
        certificate: $(CodeSigningCertificate)
        files: $(Build.ArtifactStagingDirectory)/*.exe
```

#### 6.3.2 版本管理：语义化版本 + GitVersion

| 分支 | 版本格式 | 示例 |
| --- | --- | --- |
| main / master | MAJOR.MINOR.PATCH | 2.5.3 |
| develop | MAJOR.MINOR.PATCH-alpha.N | 2.6.0-alpha.4 |
| feature/* | MAJOR.MINOR.PATCH-alpha.N+BranchName | 2.6.0-alpha.4+order-refactor |
| release/* | MAJOR.MINOR.PATCH-beta.N | 2.6.0-beta.2 |
| hotfix/* | MAJOR.MINOR.PATCH+1 | 2.5.4 |

GitVersion 配置（GitVersion.yml）：

```yaml
mode: ContinuousDeployment
branches:
  main:
    regex: ^main$
    tag: ''
    increment: Patch
  feature:
    regex: ^feature[/-]
    tag: alpha
    increment: Inherit
  release:
    regex: ^release[/-]
    tag: beta
    increment: None
```

#### 6.3.3 发布策略：单文件发布 + 自动更新机制

单文件发布配置：

```xml
<!-- .csproj -->
<PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>true</PublishSingleFile>
    <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
    <EnableCompressionInSingleFile>true</EnableCompressionInSingleFile>
</PropertyGroup>
```

自动更新机制（使用 NetSparkle 或自建）：

```csharp
public class UpdateService : BackgroundService
{
    private readonly IUpdateChecker _updateChecker;
    private readonly ILogger<UpdateService> _logger;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                var updateInfo = await _updateChecker.CheckForUpdateAsync();
                if (updateInfo.IsUpdateAvailable)
                {
                    _logger.LogInformation(
                        "Update available: {Version}",
                        updateInfo.Version);

                    // 提示用户或自动下载
                    if (updateInfo.IsMandatory)
                    {
                        await ApplyMandatoryUpdate(updateInfo);
                    }
                    else
                    {
                        NotifyOptionalUpdate(updateInfo);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Update check failed");
            }

            await Task.Delay(TimeSpan.FromHours(4), stoppingToken);
        }
    }
}
```

## 7. 性能与可维护性优化

### 7.1 启动性能

#### 7.1.1 WebView2预加载与缓存策略

| 策略 | 实现方式 | 效果 |
| --- | --- | --- |
| **预创建环境** | 应用启动时调用 CoreWebView2Environment.CreateAsync | 减少首次导航等待 200-500ms |
| **缓存用户数据** | 固定用户数据文件夹路径 | 保留 Cookie、LocalStorage、缓存资源 |
| **预加载关键资源** | 在隐藏 WebView2 中预加载常用页面 | 用户感知零加载时间 |
| **Service Worker 缓存** | 前端注册 Service Worker 缓存静态资源 | 离线可用，重复访问瞬时加载 |

#### 7.1.2 后端服务懒加载与并行初始化

```csharp
public class StartupInitializer : IHostedService
{
    private readonly IEnumerable<ILazyInitializer> _initializers;

    public async Task StartAsync(CancellationToken ct)
    {
        // 并行初始化独立服务
        await Task.WhenAll(_initializers
            .Where(i => !i.HasDependencies)
            .Select(i => i.InitializeAsync(ct)));

        // 按依赖顺序初始化其余服务
        foreach (var initializer in _initializers.Where(i => i.HasDependencies))
        {
            await initializer.InitializeAsync(ct);
        }
    }
}
```

### 7.2 运行时性能

#### 7.2.1 内存管理：IDisposable模式与GC优化

| 场景 | 推荐模式 | 注意事项 |
| --- | --- | --- |
| **短期资源** | using 语句 | 确保确定性释放 |
| **异步资源** | await using | C# 8+ 异步释放 |
| **长期持有的可释放对象** | 实现 IAsyncDisposable | 避免终结器队列压力 |
| **大型对象池** | ArrayPool<T> / MemoryPool<T> | 减少 LOH 分配 |
| **非托管内存** | Span<T> / Memory<T> | 安全包装，避免指针操作 |

#### 7.2.2 异步模式：async/await最佳实践与死锁避免

| 反模式 | 问题 | 正确做法 |
| --- | --- | --- |
| .Result / .Wait() | 阻塞线程，可能导致死锁 | 全程使用 await |
| async void | 无法捕获异常，无法取消 | 返回 Task 或 Task<T> |
| 不传递 CancellationToken | 操作无法取消，资源泄漏 | 始终传递并检查 ct.IsCancellationRequested |
| 捕获同步上下文的不必要 ConfigureAwait(true) | UI 线程拥塞 | 库代码使用 .ConfigureAwait(false) |

### 7.3 可观测性

#### 7.3.1 结构化日志：Serilog + 上下文关联

```csharp
// 配置
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .Enrich.FromLogContext()
    .Enrich.WithMachineName()
    .Enrich.WithThreadId()
    .WriteTo.Console(new JsonFormatter())
    .WriteTo.File(
        new CompactJsonFormatter(),
        "logs/app-.clef",
        rollingInterval: RollingInterval.Day,
        retainedFileCountLimit: 7)
    .WriteTo.Seq("http://localhost:5341")
    .CreateLogger();

// 使用：上下文关联
using (LogContext.PushProperty("CorrelationId", correlationId))
using (LogContext.PushProperty("UserId", userId))
{
    _logger.LogInformation(
        "Processing order {OrderId} for {CustomerId}",
        orderId, customerId);
    // 此范围内的所有日志自动包含 CorrelationId 和 UserId
}
```

#### 7.3.2 性能指标：OpenTelemetry + 本地仪表盘

| 信号类型 | 采集方式 | 本地存储方案 |
| --- | --- | --- |
| **Traces** | ActivitySource 手动或自动埋点 | Zipkin UI、Jaeger All-in-One |
| **Metrics** | Meter 计数器、直方图、观测仪表 | Prometheus + Grafana |
| **Logs** | ILogger 输出到 OTLP | Seq、Grafana Loki |

```csharp
// OpenTelemetry 配置
services.AddOpenTelemetry()
    .WithTracing(builder => builder
        .AddSource("MyApp.WebView2")
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddOtlpExporter())
    .WithMetrics(builder => builder
        .AddMeter("MyApp.Business")
        .AddPrometheusExporter());
```

## 8. 项目演进与团队协作

### 8.1 模块化演进策略

#### 8.1.1 从单体到插件化的渐进路径

| 阶段 | 特征 | 技术实现 |
| --- | --- | --- |
| **单体应用** | 所有功能编译为单一程序集 | 垂直切片组织，共享内核 |
| **模块化单体** | 功能模块独立项目，运行时统一 | 模块接口契约，动态加载 |
| **插件化架构** | 功能模块独立部署，运行时动态发现 | MEF、DI 容器扩展、AssemblyLoadContext |
| **微前端 + 微服务** | UI 和功能完全独立，按需加载 | 模块联邦、独立 WebView2 实例、gRPC |

#### 8.1.2 功能开关与A/B测试基础设施

```csharp
public interface IFeatureManager
{
    bool IsEnabled(string featureName);
    Task<bool> IsEnabledAsync(string featureName, UserContext user);
}

public class FeatureManager : IFeatureManager
{
    private readonly IConfiguration _config;
    private readonly IExperimentService _experiments;

    public bool IsEnabled(string featureName) =>
        _config.GetValue<bool>($"Features:{featureName}:Enabled");

    public async Task<bool> IsEnabledAsync(string featureName, UserContext user)
    {
        var feature = _config.GetSection($"Features:{featureName}");
        if (!feature.GetValue<bool>("Enabled")) return false;

        var experiment = feature.GetValue<string>("Experiment");
        if (string.IsNullOrEmpty(experiment)) return true;

        return await _experiments.IsInTreatmentGroupAsync(
            experiment,
            user.Id);
    }
}

// 使用
if (await _featureManager.IsEnabledAsync("NewDashboard", currentUser))
{
    // 展示新功能
}
```

### 8.2 团队代码所有权

#### 8.2.1 代码审查流程与质量门禁

| 检查层级 | 触发时机 | 检查内容 | 阻断发布 |
| --- | --- | --- | --- |
| **预提交** | 本地 commit | EditorConfig 格式、编译错误 | 是 |
| **PR 构建** | 创建/更新 Pull Request | 编译、单元测试、代码覆盖率 | 是 |
| **代码审查** | 人工审查 | 架构合规、业务逻辑、安全 | 是 |
| **集成测试** | PR 合并前 | 端到端场景、性能基准 | 是 |
| **安全扫描** | 每日/发布前 | 依赖漏洞、密钥泄露、注入风险 | 是 |

#### 8.2.2 知识共享：架构决策记录与技术雷达

**架构决策记录（ADR）模板**：

```markdown
# ADR [编号]: [标题]

## 状态
提议 / 已接受 / 已弃用 / 已替代

## 背景
[描述需要决策的问题和约束条件]

## 决策
[明确陈述所做的决策]

## 后果
### 正面
- [列表]

### 负面
- [列表]

## 替代方案
- [方案1]
  - [未选择的原因]
- [方案2]
  - [未选择的原因]

## 相关决策
- [链接到相关 ADR]
```

**技术雷达**（定期更新，可视化技术采纳状态）：

| 象限 | 技术/实践 | 环位 | 备注 |
| --- | --- | --- | --- |
| 技术 | .NET 8 AOT | 试验 | 评估单文件发布收益 |
| 技术 | WebView2 共享缓冲区 | 采用 | 大文件传输优化 |
| 工具 | Cursor AI IDE | 采用 | 主力开发工具 |
| 工具 | GitHub Copilot | 评估 | 与 Cursor 对比 |
| 平台 | Windows App SDK | 观察 | 未来迁移候选 |
| 平台 | MAUI Blazor Hybrid | 暂缓 | 等待成熟度提升 |
