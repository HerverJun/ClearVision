/**
 * 结果面板组件 - 阶段二增强版
 * 现代化数据可视化仪表板
 */

import httpClient from '../../core/messaging/httpClient.js';

class ResultPanel {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.results = [];
        this.filteredResults = [];
        this.statistics = {
            total: 0,
            ok: 0,
            ng: 0,
            error: 0,
            avgTime: 0
        };
        
        // 分页
        this.currentPage = 1;
        this.pageSize = 12;
        this.totalPages = 1;
        
        // 筛选
        this.filters = {
            status: 'all',
            defectType: 'all',
            startTime: null,
            endTime: null
        };
        
        // 时间范围
        this.timeRange = 'today';
        
        // 趋势图数据
        this.trendData = [];
        
        // 缺陷类型统计
        this.defectTypes = {};
        
        // 绑定事件
        this.bindEvents();
        
        console.log('[ResultPanel] 结果面板初始化完成');
    }
    
    /**
     * 绑定事件
     */
    bindEvents() {
        // 时间范围选择
        document.querySelectorAll('.time-range-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.time-range-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                this.setTimeRange(e.target.dataset.range);
            });
        });
        
        // 状态筛选
        const statusFilter = document.getElementById('filter-status');
        if (statusFilter) {
            statusFilter.addEventListener('change', (e) => {
                this.setFilter('status', e.target.value);
            });
        }
        
        // 缺陷类型筛选
        const defectTypeFilter = document.getElementById('filter-defect-type');
        if (defectTypeFilter) {
            defectTypeFilter.addEventListener('change', (e) => {
                this.setFilter('defectType', e.target.value);
            });
        }
        
        // 导出下拉菜单
        const exportDropdown = document.getElementById('export-dropdown');
        const exportBtn = document.getElementById('btn-export-results');
        if (exportBtn && exportDropdown) {
            exportBtn.addEventListener('click', () => {
                exportDropdown.classList.toggle('open');
            });
            
            // 导出选项
            exportDropdown.querySelectorAll('.export-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    const format = item.dataset.format;
                    this.exportResults(format);
                    exportDropdown.classList.remove('open');
                });
            });
            
            // 点击外部关闭
            document.addEventListener('click', (e) => {
                if (!exportDropdown.contains(e.target)) {
                    exportDropdown.classList.remove('open');
                }
            });
        }
    }
    
    /**
     * 设置时间范围
     */
    setTimeRange(range) {
        this.timeRange = range;
        const now = new Date();
        
        switch (range) {
            case 'today':
                this.filters.startTime = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                this.filters.endTime = now;
                break;
            case 'week':
                const weekStart = new Date(now);
                weekStart.setDate(now.getDate() - now.getDay());
                weekStart.setHours(0, 0, 0, 0);
                this.filters.startTime = weekStart;
                this.filters.endTime = now;
                break;
            case 'month':
                this.filters.startTime = new Date(now.getFullYear(), now.getMonth(), 1);
                this.filters.endTime = now;
                break;
            case 'custom':
                // 保持当前筛选或重置
                break;
        }
        
        this.applyFilters();
        this.render();
    }
    
    /**
     * 更新统计
     */
    updateStatistics(stats) {
        this.statistics = { ...this.statistics, ...stats };
        this.renderKPIs();
        this.renderYieldChart();
    }
    
    /**
     * 添加结果
     */
    addResult(result) {
        this.results.unshift(result);
        this.applyFilters();
        
        // 更新统计
        this.statistics.total++;
        if (result.status === 'OK') {
            this.statistics.ok++;
        } else if (result.status === 'NG') {
            this.statistics.ng++;
        } else if (result.status === 'Error') {
            this.statistics.error++;
        }
        
        // 更新平均耗时
        if (result.processingTime) {
            const validResults = this.results.filter(r => r.processingTime);
            const totalTime = validResults.reduce((sum, r) => sum + r.processingTime, 0);
            this.statistics.avgTime = validResults.length > 0 ? Math.round(totalTime / validResults.length) : 0;
        }
        
        // 更新趋势图数据
        this.trendData.push({
            time: new Date(result.timestamp || Date.now()),
            status: result.status,
            defectCount: result.defects?.length || 0
        });
        if (this.trendData.length > 100) {
            this.trendData.shift();
        }
        
        // 更新缺陷类型统计
        if (result.defects) {
            result.defects.forEach(defect => {
                const type = defect.type || defect.description || '未知';
                this.defectTypes[type] = (this.defectTypes[type] || 0) + 1;
            });
        }
        
        this.render();
    }
    
    /**
     * 加载历史结果
     */
    loadResults(results, total = null) {
        this.results = results;
        this.applyFilters();
        this.calculateStatistics();
        this.updateTrendData();
        this.render();
    }
    
    /**
     * 计算统计
     */
    calculateStatistics() {
        const total = this.results.length;
        const ok = this.results.filter(r => r.status === 'OK').length;
        const ng = this.results.filter(r => r.status === 'NG').length;
        const error = this.results.filter(r => r.status === 'Error').length;
        
        const validResults = this.results.filter(r => r.processingTime);
        const totalTime = validResults.reduce((sum, r) => sum + (r.processingTime || 0), 0);
        const avgTime = validResults.length > 0 ? Math.round(totalTime / validResults.length) : 0;
        
        this.statistics = { total, ok, ng, error, avgTime };
        
        // 重新计算缺陷类型
        this.defectTypes = {};
        this.results.forEach(r => {
            if (r.defects) {
                r.defects.forEach(defect => {
                    const type = defect.type || defect.description || '未知';
                    this.defectTypes[type] = (this.defectTypes[type] || 0) + 1;
                });
            }
        });
        
        // 更新缺陷类型下拉框
        this.updateDefectTypeFilter();
    }
    
    /**
     * 更新缺陷类型筛选器
     */
    updateDefectTypeFilter() {
        const select = document.getElementById('filter-defect-type');
        if (!select) return;
        
        const currentValue = select.value;
        select.innerHTML = '<option value="all">全部</option>';
        
        Object.keys(this.defectTypes).forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = `${type} (${this.defectTypes[type]})`;
            select.appendChild(option);
        });
        
        select.value = currentValue;
    }
    
    /**
     * 更新趋势图数据
     */
    updateTrendData() {
        this.trendData = this.results
            .slice(0, 100)
            .map(r => ({
                time: new Date(r.timestamp || Date.now()),
                status: r.status,
                defectCount: r.defects?.length || 0
            }))
            .reverse();
    }
    
    applyFilters() {
        this.filteredResults = this.results.filter(r => {
            // 状态筛选
            if (this.filters.status !== 'all' && r.status?.toLowerCase() !== this.filters.status) {
                return false;
            }
            
            // 缺陷类型筛选
            if (this.filters.defectType !== 'all') {
                const hasDefectType = r.defects?.some(d => 
                    (d.type || d.description || '未知') === this.filters.defectType
                );
                if (!hasDefectType) return false;
            }
            
            // 时间范围筛选
            if (this.filters.startTime) {
                const resultTime = new Date(r.timestamp).getTime();
                if (resultTime < this.filters.startTime.getTime()) {
                    return false;
                }
            }
            
            if (this.filters.endTime) {
                const resultTime = new Date(r.timestamp).getTime();
                if (resultTime > this.filters.endTime.getTime()) {
                    return false;
                }
            }
            
            return true;
        });
        
        // 重新计算总页数
        this.totalPages = Math.ceil(this.filteredResults.length / this.pageSize) || 1;
        
        // 确保当前页有效
        if (this.currentPage > this.totalPages) {
            this.currentPage = this.totalPages;
        }
    }
    
    /**
     * 设置筛选条件
     */
    setFilter(type, value) {
        this.filters[type] = value;
        this.currentPage = 1;
        this.applyFilters();
        this.render();
    }
    
    /**
     * 翻页
     */
    goToPage(page) {
        if (page < 1 || page > this.totalPages) return;
        this.currentPage = page;
        this.render();
    }
    
    /**
     * 清空结果
     */
    clear() {
        this.results = [];
        this.filteredResults = [];
        this.trendData = [];
        this.defectTypes = {};
        this.statistics = { total: 0, ok: 0, ng: 0, error: 0, avgTime: 0 };
        this.currentPage = 1;
        this.applyFilters();
        this.render();
    }
    
    /**
     * 渲染面板
     */
    render() {
        this.renderKPIs();
        this.renderYieldChart();
        this.renderDefectDistribution();
        this.renderTrendChart();
        this.renderResultsList();
        this.renderPagination();
    }
    
    /**
     * 渲染KPI卡片
     */
    renderKPIs() {
        const { total, ok, ng, error, avgTime } = this.statistics;
        const yieldRate = total > 0 ? ((ok / total) * 100).toFixed(1) : '0';
        
        const kpiTotal = document.getElementById('kpi-total');
        const kpiOk = document.getElementById('kpi-ok');
        const kpiNg = document.getElementById('kpi-ng');
        const kpiYield = document.getElementById('kpi-yield');
        const kpiAvgTime = document.getElementById('kpi-avg-time');
        
        if (kpiTotal) kpiTotal.textContent = total;
        if (kpiOk) kpiOk.textContent = ok;
        if (kpiNg) kpiNg.textContent = ng;
        if (kpiYield) kpiYield.textContent = `${yieldRate}%`;
        if (kpiAvgTime) kpiAvgTime.textContent = `${avgTime}ms`;
    }
    
    /**
     * 渲染良率环形图
     */
    renderYieldChart() {
        const { total, ok } = this.statistics;
        const yieldRate = total > 0 ? (ok / total) : 0;
        const percentage = (yieldRate * 100).toFixed(1);
        
        // 更新百分比文字
        const yieldPercentage = document.getElementById('yield-percentage');
        if (yieldPercentage) yieldPercentage.textContent = `${percentage}%`;
        
        // 更新SVG环形图
        const fillCircle = document.getElementById('yield-chart-fill');
        if (fillCircle) {
            const circumference = 2 * Math.PI * 60; // r=60
            const offset = circumference * (1 - yieldRate);
            fillCircle.style.strokeDasharray = circumference;
            fillCircle.style.strokeDashoffset = offset;
            fillCircle.style.stroke = yieldRate > 0.9 ? '#2ecc71' : yieldRate > 0.7 ? '#f1c40f' : '#e74c3c';
            fillCircle.style.transition = 'stroke-dashoffset 0.5s ease';
        }
    }
    
    /**
     * 渲染缺陷类型分布
     */
    renderDefectDistribution() {
        const container = document.getElementById('defect-bars');
        if (!container) return;
        
        const types = Object.entries(this.defectTypes);
        if (types.length === 0) {
            container.innerHTML = '<p class="empty-text">暂无缺陷数据</p>';
            return;
        }
        
        const maxCount = Math.max(...types.map(([, count]) => count));
        
        container.innerHTML = types.map(([type, count]) => `
            <div class="defect-bar-item">
                <div class="defect-bar-header">
                    <span class="defect-bar-label">${type}</span>
                    <span class="defect-bar-value">${count}</span>
                </div>
                <div class="defect-bar-track">
                    <div class="defect-bar-fill" style="width:${(count/maxCount*100).toFixed(1)}%"></div>
                </div>
            </div>
        `).join('');
    }
    
    /**
     * 渲染趋势图
     */
    renderTrendChart() {
        const canvas = document.getElementById('trend-canvas');
        if (!canvas) return;
        
        // Optimize for Retina display
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        
        const width = rect.width;
        const height = rect.height;
        const padding = 20;
        
        // 清空画布
        ctx.clearRect(0, 0, width, height);
        
        if (this.trendData.length < 2) {
            ctx.fillStyle = '#64748b';
            ctx.font = '14px "Inter", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('数据不足，无法显示趋势图', width / 2, height / 2);
            return;
        }
        
        // 绘制背景网格
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
            const y = padding + (height - 2 * padding) * i / 5;
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(width - padding, y);
            ctx.stroke();
        }
        
        const chartWidth = width - 2 * padding;
        const chartHeight = height - 2 * padding;
        const stepX = chartWidth / (this.trendData.length - 1);
        
        // 状态映射到Y坐标
        const statusY = {
            'OK': padding + chartHeight * 0.2,
            'NG': padding + chartHeight * 0.5,
            'Error': padding + chartHeight * 0.8
        };
        
        // 绘制连线
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        this.trendData.forEach((point, index) => {
            const x = padding + index * stepX;
            const y = statusY[point.status] || padding + chartHeight * 0.5;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        
        // 绘制数据点
        this.trendData.forEach((point, index) => {
            const x = padding + index * stepX;
            const y = statusY[point.status] || padding + chartHeight * 0.5;
            
            if (point.status === 'OK') {
                ctx.fillStyle = '#10b981';
            } else if (point.status === 'NG') {
                ctx.fillStyle = '#ef4444';
            } else {
                ctx.fillStyle = '#f59e0b';
            }
            
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // 绘制Y轴标签
        ctx.fillStyle = '#94a3b8';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText('OK', padding - 8, padding + chartHeight * 0.2 + 4);
        ctx.fillText('NG', padding - 8, padding + chartHeight * 0.5 + 4);
        ctx.fillText('Error', padding - 8, padding + chartHeight * 0.8 + 4);
    }
    
    /**
     * 渲染结果列表
     */
    renderResultsList() {
        const gridContainer = document.getElementById('results-grid');
        const countInfo = document.getElementById('results-count-info');
        if (!gridContainer) return;
        
        if (countInfo) {
            countInfo.textContent = `共 ${this.filteredResults.length} 条记录`;
        }
        
        if (this.filteredResults.length === 0) {
            gridContainer.innerHTML = '<p class="empty-text">暂无检测结果</p>';
            return;
        }
        
        // 计算当前页的数据
        const startIndex = (this.currentPage - 1) * this.pageSize;
        const endIndex = Math.min(startIndex + this.pageSize, this.filteredResults.length);
        const pageResults = this.filteredResults.slice(startIndex, endIndex);
        
        gridContainer.innerHTML = pageResults.map((result, index) => {
            const statusClass = result.status?.toLowerCase() || 'unknown';
            const time = result.timestamp ? new Date(result.timestamp).toLocaleTimeString() : '--:--:--';
            const processingTime = result.processingTime || result.executionTimeMs || '--';
            const globalIndex = startIndex + index;
            
            return `
                <div class="result-card result-${statusClass}" data-index="${globalIndex}" style="cursor:pointer;">
                    <div class="result-card-header">
                        <span class="result-status-badge ${statusClass}">${result.status || 'Unknown'}</span>
                        <span class="result-time">${time}</span>
                    </div>
                    <div class="result-card-body">
                        <span class="result-processing-time">${processingTime}ms</span>
                        ${result.defects?.length > 0 ? `<span class="result-defect-count">${result.defects.length} 缺陷</span>` : ''}
                    </div>
                </div>
            `;
        }).join('');
        
        // 绑定点击事件
        gridContainer.querySelectorAll('.result-card').forEach(card => {
            card.addEventListener('click', (e) => {
                const index = parseInt(e.currentTarget.dataset.index);
                const result = this.filteredResults[index];
                if (result) {
                    this.showResultDetail(result);
                }
            });
        });
    }
    
    /**
     * 渲染分页控件
     */
    renderPagination() {
        const paginationContainer = document.getElementById('results-pagination');
        if (!paginationContainer) return;
        
        if (this.totalPages <= 1) {
            paginationContainer.innerHTML = '';
            return;
        }
        
        let pageButtons = '';
        const maxVisiblePages = 5;
        let startPage = Math.max(1, this.currentPage - Math.floor(maxVisiblePages / 2));
        let endPage = Math.min(this.totalPages, startPage + maxVisiblePages - 1);
        
        if (endPage - startPage < maxVisiblePages - 1) {
            startPage = Math.max(1, endPage - maxVisiblePages + 1);
        }
        
        // 上一页
        pageButtons += `<button class="page-btn ${this.currentPage === 1 ? 'disabled' : ''}" 
            ${this.currentPage === 1 ? 'disabled' : ''} data-page="${this.currentPage - 1}">«</button>`;
        
        if (startPage > 1) {
            pageButtons += `<button class="page-btn" data-page="1">1</button>`;
            if (startPage > 2) pageButtons += `<span class="page-ellipsis">...</span>`;
        }
        
        for (let i = startPage; i <= endPage; i++) {
            pageButtons += `<button class="page-btn ${i === this.currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
        }
        
        if (endPage < this.totalPages) {
            if (endPage < this.totalPages - 1) pageButtons += `<span class="page-ellipsis">...</span>`;
            pageButtons += `<button class="page-btn" data-page="${this.totalPages}">${this.totalPages}</button>`;
        }
        
        // 下一页
        pageButtons += `<button class="page-btn ${this.currentPage === this.totalPages ? 'disabled' : ''}" 
            ${this.currentPage === this.totalPages ? 'disabled' : ''} data-page="${this.currentPage + 1}">»</button>`;
        
        paginationContainer.innerHTML = pageButtons;
        
        // 绑定分页事件
        paginationContainer.querySelectorAll('.page-btn:not(.disabled)').forEach(btn => {
            btn.addEventListener('click', () => {
                const page = parseInt(btn.dataset.page);
                if (page) this.goToPage(page);
            });
        });
    }
    
    /**
     * 导出结果
     */
    exportResults(format = 'json') {
        if (this.filteredResults.length === 0) {
            alert('没有可导出的结果');
            return;
        }
        
        let content, filename, mimeType;
        
        switch (format) {
            case 'json':
                content = JSON.stringify(this.filteredResults, null, 2);
                filename = `inspection_results_${Date.now()}.json`;
                mimeType = 'application/json';
                break;
            case 'csv':
            case 'excel':
                content = this.convertToCSV(this.filteredResults);
                filename = `inspection_results_${Date.now()}.csv`;
                mimeType = 'text/csv';
                break;
            default:
                throw new Error(`不支持的导出格式: ${format}`);
        }
        
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    /**
     * 转换为 CSV
     */
    convertToCSV(results) {
        const headers = ['时间', '状态', '缺陷数', '处理时间(ms)', '置信度'];
        const rows = results.map(r => [
            r.timestamp ? new Date(r.timestamp).toISOString() : '',
            r.status,
            r.defects?.length || 0,
            r.processingTime || r.executionTimeMs || '',
            r.defects?.[0]?.confidenceScore ? (r.defects[0].confidenceScore * 100).toFixed(1) + '%' : ''
        ]);
        
        return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
    }
    
    /**
     * 显示结果详情
     */
    showResultDetail(result) {
        console.log('[ResultPanel] 查看结果详情:', result);
        // 可扩展为弹窗展示
    }
    
    /**
     * 获取最新结果
     */
    getLatestResult() {
        return this.filteredResults[0] || null;
    }
    
    /**
     * 获取所有结果
     */
    getAllResults() {
        return [...this.filteredResults];
    }
}

// 创建全局实例供HTML事件使用
let resultPanel = null;

export default ResultPanel;
export { ResultPanel };
