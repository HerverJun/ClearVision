using System.Collections.Concurrent;
using Acme.Product.Core.Entities;
using Acme.Product.Core.Enums;
using Acme.Product.Core.Operators;
using Acme.Product.Core.Services;
using Acme.Product.Infrastructure.Logging;
using Acme.Product.Infrastructure.Operators;
using Microsoft.Extensions.Logging;

namespace Acme.Product.Infrastructure.Services;

/// <summary>
/// 流程执行服务实现
/// </summary>
public class FlowExecutionService : IFlowExecutionService
{
    private readonly ConcurrentDictionary<Guid, FlowExecutionStatus> _executionStatuses = new();
    private readonly Dictionary<OperatorType, IOperatorExecutor> _executors;
    private readonly ILogger<FlowExecutionService> _logger;
    private readonly ConcurrentDictionary<Guid, CancellationTokenSource> _executionCancellations = new();

    public FlowExecutionService(IEnumerable<IOperatorExecutor> executors, ILogger<FlowExecutionService> logger)
    {
        _executors = executors.ToDictionary(e => e.OperatorType);
        _logger = logger;
    }

    public async Task<FlowExecutionResult> ExecuteFlowAsync(
        OperatorFlow flow,
        Dictionary<string, object>? inputData = null,
        bool enableParallel = false,
        CancellationToken cancellationToken = default)
    {
        var result = new FlowExecutionResult();
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();

        // 创建链接的 CancellationTokenSource
        var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        _executionCancellations[flow.Id] = cts;

        try
        {
            // 获取执行顺序（拓扑排序）
            var executionOrder = flow.GetExecutionOrder().ToList();

            // 初始化执行状态
            var status = new FlowExecutionStatus
            {
                FlowId = flow.Id,
                IsExecuting = true,
                StartTime = DateTime.UtcNow,
                ProgressPercentage = 0
            };
            _executionStatuses[flow.Id] = status;

            // 存储每个算子的输出 - 使用 ConcurrentDictionary 支持并行执行
            var operatorOutputs = new ConcurrentDictionary<Guid, Dictionary<string, object>>();

            // 设置初始输入数据
            if (inputData != null)
            {
                operatorOutputs[Guid.Empty] = inputData;
            }

            if (enableParallel && executionOrder.Count > 1)
            {
                // 并行执行模式
                await ExecuteFlowParallelAsync(flow, executionOrder, operatorOutputs, result, status, cts.Token);
            }
            else
            {
                // 顺序执行模式
                await ExecuteFlowSequentialAsync(flow, executionOrder, operatorOutputs, result, status, cts.Token);
            }

            stopwatch.Stop();
            result.ExecutionTimeMs = stopwatch.ElapsedMilliseconds;

            // 检查是否因为取消而中止
            if (cts.Token.IsCancellationRequested)
            {
                result.IsSuccess = false;
                result.ErrorMessage = "流程被取消";
            }
            else
            {
                result.IsSuccess = result.OperatorResults.All(r => r.IsSuccess);
            }

            // 记录流程执行完成日志
            _logger.LogFlowExecution(flow.Id, executionOrder.Count, stopwatch.ElapsedMilliseconds, result.IsSuccess);

            // 获取最后一个算子的输出作为流程输出
            if (executionOrder.Any() && operatorOutputs.ContainsKey(executionOrder.Last().Id))
            {
                result.OutputData = ConvertImageWrappersToBytes(operatorOutputs[executionOrder.Last().Id]);
            }

            status.IsExecuting = false;
            status.ProgressPercentage = 100;

            return result;
        }
        catch (OperationCanceledException)
        {
            stopwatch.Stop();
            result.IsSuccess = false;
            result.ErrorMessage = "流程被取消";
            result.ExecutionTimeMs = stopwatch.ElapsedMilliseconds;
            return result;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            result.IsSuccess = false;
            result.ErrorMessage = $"流程执行异常: {ex.Message}";
            result.ExecutionTimeMs = stopwatch.ElapsedMilliseconds;
            _logger.LogError(ex, "流程执行异常: {FlowId}", flow.Id);
            return result;
        }
        finally
        {
            // 清理 CancellationTokenSource
            if (_executionCancellations.TryRemove(flow.Id, out var removedCts))
            {
                removedCts.Dispose();
            }

            if (_executionStatuses.TryGetValue(flow.Id, out var status))
            {
                status.IsExecuting = false;
            }
        }
    }

    /// <summary>
    /// 顺序执行流程
    /// </summary>
    private async Task ExecuteFlowSequentialAsync(
        OperatorFlow flow,
        List<Operator> executionOrder,
        ConcurrentDictionary<Guid, Dictionary<string, object>> operatorOutputs,
        FlowExecutionResult result,
        FlowExecutionStatus status,
        CancellationToken cancellationToken)
    {
        int completedCount = 0;
        foreach (var op in executionOrder)
        {
            // 检查取消
            if (cancellationToken.IsCancellationRequested)
            {
                break;
            }

            if (!_executors.TryGetValue(op.Type, out var executor))
            {
                result.OperatorResults.Add(new OperatorExecutionResult
                {
                    OperatorId = op.Id,
                    OperatorName = op.Name,
                    IsSuccess = false,
                    ErrorMessage = $"未找到类型为 {op.Type} 的算子执行器"
                });
                continue;
            }

            // 更新当前执行状态
            status.CurrentOperatorId = op.Id;
            status.ProgressPercentage = (double)completedCount / executionOrder.Count * 100;

            // 准备输入数据
            var inputs = PrepareOperatorInputs(flow, op, operatorOutputs);

            // 执行算子
            var opResult = await ExecuteOperatorInternalAsync(op, executor, inputs, cancellationToken);
            result.OperatorResults.Add(opResult);

            if (!opResult.IsSuccess)
            {
                result.IsSuccess = false;
                result.ErrorMessage = $"算子 '{op.Name}' 执行失败: {opResult.ErrorMessage}";
                break;
            }

            operatorOutputs[op.Id] = opResult.OutputData ?? new Dictionary<string, object>();
            completedCount++;
        }
    }

    /// <summary>
    /// 并行执行流程 - 按层级并行执行无依赖的算子
    /// </summary>
    private async Task ExecuteFlowParallelAsync(
        OperatorFlow flow,
        List<Operator> executionOrder,
        ConcurrentDictionary<Guid, Dictionary<string, object>> operatorOutputs,
        FlowExecutionResult result,
        FlowExecutionStatus status,
        CancellationToken cancellationToken)
    {
        // 构建执行层级（哪些算子可以并行执行）
        var executionLayers = BuildExecutionLayers(flow, executionOrder);
        var completedOperators = new HashSet<Guid>();
        var failed = false;

        foreach (var layer in executionLayers)
        {
            if (failed || cancellationToken.IsCancellationRequested)
                break;

            // 更新状态
            status.CurrentOperatorId = layer.First().Id;
            status.ProgressPercentage = (double)completedOperators.Count / executionOrder.Count * 100;

            // 并行执行当前层的所有算子
            var layerTasks = layer.Select(async op =>
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    return new OperatorExecutionResult
                    {
                        IsSuccess = false,
                        ErrorMessage = "流程被取消",
                        OperatorId = op.Id,
                        OperatorName = op.Name
                    };
                }

                if (!_executors.TryGetValue(op.Type, out var executor))
                {
                    return new OperatorExecutionResult
                    {
                        OperatorId = op.Id,
                        OperatorName = op.Name,
                        IsSuccess = false,
                        ErrorMessage = $"未找到类型为 {op.Type} 的算子执行器"
                    };
                }

                // 准备输入数据
                var inputs = PrepareOperatorInputs(flow, op, operatorOutputs);

                // 执行算子
                var opResult = await ExecuteOperatorInternalAsync(op, executor, inputs, cancellationToken);

                if (opResult.IsSuccess)
                {
                    operatorOutputs[op.Id] = opResult.OutputData ?? new Dictionary<string, object>();
                }

                return opResult;
            }).ToList();

            // 等待当前层所有算子执行完成
            var layerResults = await Task.WhenAll(layerTasks);
            result.OperatorResults.AddRange(layerResults);

            // 检查是否有失败的算子
            if (layerResults.Any(r => !r.IsSuccess))
            {
                failed = true;
                var failedOp = layerResults.First(r => !r.IsSuccess);
                result.IsSuccess = false;
                result.ErrorMessage = cancellationToken.IsCancellationRequested
                    ? "流程被取消"
                    : $"算子 '{failedOp.OperatorName}' 执行失败: {failedOp.ErrorMessage}";
            }

            foreach (var op in layer)
            {
                completedOperators.Add(op.Id);
            }
        }
    }

    /// <summary>
    /// 构建执行层级 - 将算子分组，同一层的算子可以并行执行
    /// </summary>
    private List<List<Operator>> BuildExecutionLayers(OperatorFlow flow, List<Operator> executionOrder)
    {
        var layers = new List<List<Operator>>();
        var executed = new HashSet<Guid>();
        var remaining = new HashSet<Operator>(executionOrder);

        while (remaining.Any())
        {
            // 找出当前可以执行的算子（所有依赖都已执行）
            var currentLayer = remaining.Where(op =>
            {
                // 获取该算子的所有依赖（输入连接）
                var dependencies = flow.Connections
                    .Where(c => c.TargetOperatorId == op.Id)
                    .Select(c => c.SourceOperatorId);

                // 检查所有依赖是否已执行
                return dependencies.All(depId => executed.Contains(depId));
            }).ToList();

            if (!currentLayer.Any())
            {
                // 如果没有可以执行的算子，说明有循环依赖或其他问题
                // 将剩余的算子作为一个层级执行
                currentLayer = remaining.ToList();
            }

            layers.Add(currentLayer);

            foreach (var op in currentLayer)
            {
                executed.Add(op.Id);
                remaining.Remove(op);
            }
        }

        return layers;
    }

    // 默认算子执行超时时间（30秒）
    private const int DefaultOperatorTimeoutMs = 30000;

    /// <summary>
    /// 内部执行单个算子（带超时保护）
    /// </summary>
    private async Task<OperatorExecutionResult> ExecuteOperatorInternalAsync(
        Operator op,
        IOperatorExecutor executor,
        Dictionary<string, object> inputs,
        CancellationToken cancellationToken = default)
    {
        op.MarkExecutionStarted();
        var opStopwatch = System.Diagnostics.Stopwatch.StartNew();

        try
        {
            // 为算子执行添加全局超时保护
            using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            timeoutCts.CancelAfter(TimeSpan.FromMilliseconds(DefaultOperatorTimeoutMs));

            // O1.3: 传递 CancellationToken 给算子执行器，支持取消操作
            var opResult = await executor.ExecuteAsync(op, inputs, timeoutCts.Token);
            opStopwatch.Stop();

            if (cancellationToken.IsCancellationRequested)
            {
                return new OperatorExecutionResult
                {
                    OperatorId = op.Id,
                    OperatorName = op.Name,
                    IsSuccess = false,
                    ExecutionTimeMs = opStopwatch.ElapsedMilliseconds,
                    ErrorMessage = "算子执行被取消"
                };
            }

            if (opResult.IsSuccess)
            {
                op.MarkExecutionCompleted(opStopwatch.ElapsedMilliseconds);
                _logger.LogOperatorExecution(op.Id, op.Name, opStopwatch.ElapsedMilliseconds, true);

                return new OperatorExecutionResult
                {
                    OperatorId = op.Id,
                    OperatorName = op.Name,
                    IsSuccess = true,
                    ExecutionTimeMs = opStopwatch.ElapsedMilliseconds,
                    OutputData = opResult.OutputData
                };
            }
            else
            {
                op.MarkExecutionFailed(opResult.ErrorMessage ?? "未知错误");
                _logger.LogOperatorExecution(op.Id, op.Name, opStopwatch.ElapsedMilliseconds, false);
                _logger.LogError("算子执行失败: {OperatorName} ({OperatorId}), 错误: {ErrorMessage}",
                    op.Name, op.Id, opResult.ErrorMessage);

                return new OperatorExecutionResult
                {
                    OperatorId = op.Id,
                    OperatorName = op.Name,
                    IsSuccess = false,
                    ExecutionTimeMs = opStopwatch.ElapsedMilliseconds,
                    ErrorMessage = opResult.ErrorMessage
                };
            }
        }
        catch (OperationCanceledException) when (!cancellationToken.IsCancellationRequested)
        {
            opStopwatch.Stop();
            op.MarkExecutionFailed($"算子执行超时 ({DefaultOperatorTimeoutMs/1000}秒)");
            _logger.LogError("算子执行超时: {OperatorName} ({OperatorId})", op.Name, op.Id);

            return new OperatorExecutionResult
            {
                OperatorId = op.Id,
                OperatorName = op.Name,
                IsSuccess = false,
                ExecutionTimeMs = opStopwatch.ElapsedMilliseconds,
                ErrorMessage = $"算子 '{op.Name}' 执行超时 ({DefaultOperatorTimeoutMs/1000}秒)"
            };
        }
        catch (Exception ex)
        {
            opStopwatch.Stop();
            op.MarkExecutionFailed(ex.Message);
            _logger.LogError(ex, "算子执行异常: {OperatorName} ({OperatorId})", op.Name, op.Id);

            return new OperatorExecutionResult
            {
                OperatorId = op.Id,
                OperatorName = op.Name,
                IsSuccess = false,
                ExecutionTimeMs = opStopwatch.ElapsedMilliseconds,
                ErrorMessage = ex.Message
            };
        }
    }

    public async Task<OperatorExecutionResult> ExecuteOperatorAsync(Operator @operator, Dictionary<string, object>? inputs = null)
    {
        if (!_executors.TryGetValue(@operator.Type, out var executor))
        {
            return new OperatorExecutionResult
            {
                OperatorId = @operator.Id,
                OperatorName = @operator.Name,
                IsSuccess = false,
                ErrorMessage = $"未找到类型为 {@operator.Type} 的算子执行器"
            };
        }

        var stopwatch = System.Diagnostics.Stopwatch.StartNew();

        try
        {
            // 对于单独执行算子，目前不支持取消
            var opResult = await executor.ExecuteAsync(@operator, inputs ?? new Dictionary<string, object>());
            stopwatch.Stop();

            _logger.LogOperatorExecution(@operator.Id, @operator.Name, stopwatch.ElapsedMilliseconds, opResult.IsSuccess);

            return new OperatorExecutionResult
            {
                OperatorId = @operator.Id,
                OperatorName = @operator.Name,
                IsSuccess = opResult.IsSuccess,
                ExecutionTimeMs = stopwatch.ElapsedMilliseconds,
                OutputData = opResult.OutputData,
                ErrorMessage = opResult.ErrorMessage
            };
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex, "算子执行异常: {OperatorName} ({OperatorId})", @operator.Name, @operator.Id);
            return new OperatorExecutionResult
            {
                OperatorId = @operator.Id,
                OperatorName = @operator.Name,
                IsSuccess = false,
                ExecutionTimeMs = stopwatch.ElapsedMilliseconds,
                ErrorMessage = ex.Message
            };
        }
    }

    public FlowValidationResult ValidateFlow(OperatorFlow flow)
    {
        var result = new FlowValidationResult();

        // 检查是否有算子
        if (!flow.Operators.Any())
        {
            result.Errors.Add("流程中没有任何算子");
            return result;
        }

        // 检查是否有图像采集算子作为输入
        var hasInputOperator = flow.Operators.Any(o => o.Type == OperatorType.ImageAcquisition);
        if (!hasInputOperator)
        {
            result.Warnings.Add("流程缺少图像采集算子作为输入");
        }

        // 检查是否有结果输出算子
        var hasOutputOperator = flow.Operators.Any(o => o.Type == OperatorType.ResultOutput);
        if (!hasOutputOperator)
        {
            result.Warnings.Add("流程缺少结果输出算子");
        }

        // 验证每个算子的参数
        foreach (var op in flow.Operators)
        {
            if (_executors.TryGetValue(op.Type, out var executor))
            {
                var validation = executor.ValidateParameters(op);
                if (!validation.IsValid)
                {
                    foreach (var error in validation.Errors)
                    {
                        result.Errors.Add($"算子 '{op.Name}': {error}");
                    }
                }
            }
        }

        result.IsValid = !result.Errors.Any();
        return result;
    }

    public FlowExecutionStatus? GetExecutionStatus(Guid flowId)
    {
        return _executionStatuses.TryGetValue(flowId, out var status) ? status : null;
    }

    public Task CancelExecutionAsync(Guid flowId)
    {
        if (_executionCancellations.TryGetValue(flowId, out var cts))
        {
            try
            {
                cts.Cancel();
                _logger.LogInformation("已请求取消流程: {FlowId}", flowId);
            }
            catch (ObjectDisposedException)
            {
                // 忽略已释放的对象异常
            }
        }

        if (_executionStatuses.TryGetValue(flowId, out var status))
        {
            status.IsExecuting = false;
        }

        return Task.CompletedTask;
    }

    /// <summary>
    /// 将输出数据中的 ImageWrapper 转换为 byte[]，以便前端序列化
    /// </summary>
    private Dictionary<string, object> ConvertImageWrappersToBytes(Dictionary<string, object>? outputData)
    {
        if (outputData == null)
            return new Dictionary<string, object>();

        var result = new Dictionary<string, object>();
        foreach (var kvp in outputData)
        {
            if (kvp.Value is ImageWrapper wrapper)
            {
                // ImageWrapper 转换为 byte[]
                result[kvp.Key] = wrapper.GetBytes();
            }
            else
            {
                result[kvp.Key] = kvp.Value;
            }
        }
        return result;
    }

    private Dictionary<string, object> PrepareOperatorInputs(OperatorFlow flow, Operator op, IDictionary<Guid, Dictionary<string, object>> operatorOutputs)
    {
        var inputs = new Dictionary<string, object>();

        // 【关键修复】首先将算子自身的参数合并到输入中作为默认值
        // 这确保了如果没有外部连线，算子依然能拿到 UI 属性面板设置的值 (如 filePath)
        foreach (var param in op.Parameters)
        {
            if (param.Value != null)
            {
                inputs[param.Name] = param.Value;
            }
        }

        // 查找连接到该算子的所有连接
        var incomingConnections = flow.Connections
            .Where(c => c.TargetOperatorId == op.Id)
            .ToList();

        // 如果没有输入连接,尝试从初始输入数据获取(Guid.Empty)
        if (!incomingConnections.Any())
        {
            if (operatorOutputs.TryGetValue(Guid.Empty, out var initialInputs))
            {
                foreach (var kvp in initialInputs)
                {
                    inputs[kvp.Key] = kvp.Value;
                }
            }
        }
        else
        {
            foreach (var connection in incomingConnections)
            {
                if (operatorOutputs.TryGetValue(connection.SourceOperatorId, out var sourceOutputs))
                {
                    // 【条件分支路由修复】检查源算子是否为条件分支
                    var sourceOperator = flow.Operators.FirstOrDefault(o => o.Id == connection.SourceOperatorId);
                    if (sourceOperator?.Type == OperatorType.ConditionalBranch)
                    {
                        // 对于条件分支算子，只传递与连接端口名称匹配的数据
                        // 获取源端口名称（True 或 False）
                        var sourcePort = sourceOperator.OutputPorts.FirstOrDefault(p => p.Id == connection.SourcePortId);
                        if (sourcePort != null)
                        {
                            var portName = sourcePort.Name;
                            // 检查输出数据中是否有对应端口的数据且不为null
                            if (sourceOutputs.TryGetValue(portName, out var portData) && portData != null)
                            {
                                // 只传递该端口的数据以及通用信息
                                inputs[portName] = portData;
                                // 同时传递判断结果等通用信息
                                if (sourceOutputs.TryGetValue("Result", out var result))
                                    inputs["ConditionResult"] = result;
                                if (sourceOutputs.TryGetValue("Condition", out var condition))
                                    inputs["Condition"] = condition;
                                if (sourceOutputs.TryGetValue("ActualValue", out var actualValue))
                                    inputs["ActualValue"] = actualValue;
                            }
                            // 如果端口数据为null，说明条件分支走的是另一分支，不传递任何数据
                        }
                    }
                    else
                    {
                        // 普通算子：将源算子的输出合并到当前算子的输入
                        foreach (var kvp in sourceOutputs)
                        {
                            inputs[kvp.Key] = kvp.Value;
                        }
                    }
                }
            }
        }

        return inputs;
    }
}
